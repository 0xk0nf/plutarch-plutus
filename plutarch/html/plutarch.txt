-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package plutarch
@version 1.1.0

module Plutarch.Api.Internal.Hashing

-- | Hash a Script with the given version prefix
hashScriptWithPrefix :: ByteString -> Script -> ScriptHash

-- | Hash Plutus <tt>Data</tt>.
hashData :: Data -> BuiltinByteString

-- | Hash <tt>LedgerBytes</tt>.
hashLedgerBytes :: LedgerBytes -> BuiltinByteString

module Plutarch.DataRepr.Internal.HList.Utils
newtype Labeled sym a
Labeled :: a -> Labeled sym a
[unLabeled] :: Labeled sym a -> a

-- | GADT proof-witness of HList membership, usable as an index
data Elem (a :: k) (as :: [k])
[Here] :: Elem a (a : as)
[There] :: Elem a as -> Elem a (b : as)

-- | Indexing type-level lists
type family IndexList (n :: Nat) (l :: [k]) :: k

-- | Indexing list of labeled pairs by label
type family IndexLabel name as

-- | Return the single item from a singleton list
type family SingleItem (as :: [k]) :: k

-- | Drop first n fields of a list
type family Drop (n :: Nat) (as :: [k]) :: [k]

module Plutarch.Evaluate

-- | Evaluate a script with a big budget, returning the trace log and term
--   result.
evalScript :: Script -> (Either EvalError Script, ExBudget, [Text])

-- | Evaluate a script with a huge budget, returning the trace log and term
--   result.
evalScriptHuge :: Script -> (Either EvalError Script, ExBudget, [Text])

-- | Evaluate a script with a specific budget, returning the trace log and
--   term result.
evalScript' :: ExBudget -> Script -> (Either (CekEvaluationException NamedDeBruijn DefaultUni DefaultFun) Script, ExBudget, [Text])
type EvalError = (CekEvaluationException NamedDeBruijn DefaultUni DefaultFun)

module Plutarch.Internal
data (:-->) (a :: PType) (b :: PType) (s :: S)
PLam :: (Term s a -> Term s b) -> (:-->) (a :: PType) (b :: PType) (s :: S)
infixr 0 :-->
data PDelayed (a :: PType) (s :: S)
newtype Term (s :: S) (a :: PType)
Term :: (Word64 -> TermMonad TermResult) -> Term (s :: S) (a :: PType)
[asRawTerm] :: Term (s :: S) (a :: PType) -> Word64 -> TermMonad TermResult
asClosedRawTerm :: ClosedTerm a -> TermMonad TermResult
mapTerm :: (RawTerm -> RawTerm) -> TermResult -> TermResult

-- | Lambda abstraction.
--   
--   Only works with a single argument. Use <tt>plam</tt> instead, to
--   support currying.
plam' :: (Term s a -> Term s b) -> Term s (a :--> b)

-- | Let bindings.
--   
--   This is appoximately a shorthand for a lambda and application:
--   
--   <tt>plet v f</tt> == <tt> papp (plam f) v</tt>
--   
--   But sufficiently small terms in WHNF may be inlined for efficiency.
plet :: Term s a -> (Term s a -> Term s b) -> Term s b

-- | Lambda Application.
papp :: HasCallStack => Term s (a :--> b) -> Term s a -> Term s b

-- | Plutus 'delay', used for laziness.
pdelay :: Term s a -> Term s (PDelayed a)

-- | Plutus 'force', used to force evaluation of <a>PDelayed</a> terms.
pforce :: Term s (PDelayed a) -> Term s a
phoistAcyclic :: HasCallStack => ClosedTerm a -> Term s a

-- | Plutus 'error'.
--   
--   When using this explicitly, it should be ensured that the containing
--   term is delayed, avoiding premature evaluation.
perror :: Term s a

-- | Unsafely coerce the type-tag of a Term.
--   
--   This should mostly be avoided, though it can be safely used to assert
--   known types of Datums, Redeemers or ScriptContext.
punsafeCoerce :: Term s a -> Term s b
punsafeBuiltin :: DefaultFun -> Term s a

-- | <i>Deprecated: Use <tt>pconstant</tt> instead.</i>
punsafeConstant :: Some (ValueOf DefaultUni) -> Term s a
punsafeConstantInternal :: Some (ValueOf DefaultUni) -> Term s a

-- | Compile a (closed) Plutus Term to a usable script
compile :: Config -> ClosedTerm a -> Either Text Script
compile' :: TermResult -> UTerm

-- | <ul>
--   <li>Closed* terms with no free variables.</li>
--   </ul>
type ClosedTerm (a :: PType) = forall (s :: S). Term s a
type Dig = Digest Blake2b_160
hashTerm :: Config -> ClosedTerm a -> Either Text Dig
hashRawTerm :: RawTerm -> Dig
data RawTerm
RVar :: Word64 -> RawTerm
RLamAbs :: Word64 -> RawTerm -> RawTerm
RApply :: RawTerm -> [RawTerm] -> RawTerm
RForce :: RawTerm -> RawTerm
RDelay :: RawTerm -> RawTerm
RConstant :: Some (ValueOf DefaultUni) -> RawTerm
RBuiltin :: DefaultFun -> RawTerm
RCompiled :: UTerm -> RawTerm
RError :: RawTerm
RHoisted :: HoistedTerm -> RawTerm
data TermResult
TermResult :: RawTerm -> [HoistedTerm] -> TermResult
[getTerm] :: TermResult -> RawTerm
[getDeps] :: TermResult -> [HoistedTerm]
data S
SI :: S

-- | Shorthand for Plutarch types.
type PType = S -> Type
pthrow :: HasCallStack => Text -> Term s a
data Config
Config :: TracingMode -> Config
[tracingMode] :: Config -> TracingMode
data TracingMode
NoTracing :: TracingMode
DoTracing :: TracingMode
DetTracing :: TracingMode
defaultConfig :: Config
pgetConfig :: (Config -> Term s a) -> Term s a
newtype TermMonad m
TermMonad :: ReaderT Config (Either Text) m -> TermMonad m
[runTermMonad] :: TermMonad m -> ReaderT Config (Either Text) m
instance GHC.Show.Show Plutarch.Internal.HoistedTerm
instance GHC.Show.Show Plutarch.Internal.RawTerm
instance GHC.Base.Monad Plutarch.Internal.TermMonad
instance GHC.Base.Applicative Plutarch.Internal.TermMonad
instance GHC.Base.Functor Plutarch.Internal.TermMonad

module Plutarch.Internal.PLam
plam :: forall c. PLamN a b s => (Term s c -> a) -> Term s (c :--> b)

-- | Low precedence infixr synonym of <a>papp</a>, to be used like
--   <a>$</a>, in combination with <a>#</a>. e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; f # x #$ g # y # z
--   f x (g y z)
--   </pre>
(#$) :: HasCallStack => Term s (a :--> b) -> Term s a -> Term s b
infixr 0 #$

-- | High precedence infixl synonym of <a>papp</a>, to be used like
--   function juxtaposition. e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; f # x # y
--   f x y
--   </pre>
(#) :: HasCallStack => Term s (a :--> b) -> Term s a -> Term s b
infixl 8 #
pinl :: Term s a -> (Term s a -> Term s b) -> Term s b
instance forall a' (s :: Plutarch.Internal.S) (a :: Plutarch.Internal.PType). ((a' :: Type) GHC.Types.~ (Plutarch.Internal.Term s a :: Type)) => Plutarch.Internal.PLam.PLamN a' a s
instance forall a' (s :: Plutarch.Internal.S) (a :: Plutarch.Internal.PType) b' (b :: Plutarch.Internal.PType). ((a' :: Type) GHC.Types.~ (Plutarch.Internal.Term s a :: Type), Plutarch.Internal.PLam.PLamN b' b s) => Plutarch.Internal.PLam.PLamN (a' -> b') (a Plutarch.Internal.:--> b) s

module Plutarch.Internal.Quantification
newtype PForall (b :: a -> PType) s
PForall :: (forall (x :: a). Term s (b x)) -> PForall (b :: a -> PType) s
data PSome (b :: a -> PType) s
PSome :: Term s (b x) -> PSome (b :: a -> PType) s
newtype PFix f s
PFix :: Term s (f (PFix f)) -> PFix f s

module Plutarch.Internal.TypeFamily

-- | Convert a list of `Term s a` to a list of <tt>a</tt>.
type family ToPType as
type family ToPType2 as
type family UnTerm x
type family Snd ab

module Plutarch.Internal.Generic

-- | <a>Generic</a> constraint extended to work with Plutarch types.
class (forall s. PGeneric' a s) => PGeneric a

-- | Like <tt>Code</tt> but for Plutarch types
type PCode a = ToPType2 (GCode (a Any))
gpfrom :: forall a s. PGeneric a => a s -> SOP (Term s) (PCode a)
gpto :: forall a s. PGeneric a => SOP (Term s) (PCode a) -> a s
instance forall (a :: Plutarch.Internal.PType). (forall (s :: Plutarch.Internal.S). Plutarch.Internal.Generic.PGeneric' a s) => Plutarch.Internal.Generic.PGeneric a
instance forall (a :: Plutarch.Internal.S -> Type) (s :: Plutarch.Internal.S). (GHC.Generics.Generic (a s), Generics.SOP.GGP.GFrom (a s), Generics.SOP.GGP.GTo (a s), Data.SOP.Constraint.All2 @{Plutarch.Internal.PType} (Data.SOP.Constraint.Top @{Plutarch.Internal.PType}) (Plutarch.Internal.Generic.PCode a), Data.SOP.Constraint.All2 @{Type} (Data.SOP.Constraint.Top @{Type}) (Generics.SOP.GGP.GCode (a s)), Generics.SOP.GGP.GDatatypeInfo (a s)) => Plutarch.Internal.Generic.PGeneric' a s
instance forall a. Generics.SOP.GGP.GTo a => Plutarch.Internal.Generic.GTo' a
instance forall a. Generics.SOP.GGP.GFrom a => Plutarch.Internal.Generic.GFrom' a

module Plutarch.Internal.Witness
witness :: c => Proxy c -> ()

module Plutarch.Internal.PlutusType
class PlutusType (a :: PType)
type PlutusTypeStratConstraint strategy :: PType -> Constraint

-- | <i>Deprecated: Use PlutusType</i>
type PCon = PlutusType

-- | <i>Deprecated: Use PlutusType</i>
type PMatch = PlutusType
pcon' :: forall s. PlutusType a => a s -> Term s (PInner a)
pmatch' :: forall s b. PlutusType a => Term s (PInner a) -> (a s -> Term s b) -> Term s b

-- | Pattern match over Plutarch Terms via a Haskell datatype
pmatch :: PlutusType a => Term s a -> (a s -> Term s b) -> Term s b

-- | Construct a Plutarch Term via a Haskell datatype
pcon :: PlutusType a => a s -> Term s a
type PInner a :: PType
class PlutusTypeStrat (strategy :: Type)
class (PInner a ~ DerivedPInner (DPTStrat a) a, PlutusTypeStrat (DPTStrat a), PlutusTypeStratConstraint (DPTStrat a) a, PlutusType a) => DerivePlutusType (a :: PType)
type DPTStrat a :: Type
type DerivedPInner strategy (a :: PType) :: PType
derivedPCon :: forall a s. (PlutusTypeStrat strategy, DerivePlutusType a, DPTStrat a ~ strategy) => a s -> Term s (DerivedPInner strategy a)
derivedPMatch :: forall a s b. (PlutusTypeStrat strategy, DerivePlutusType a, DPTStrat a ~ strategy) => Term s (DerivedPInner strategy a) -> (a s -> Term s b) -> Term s b
class (forall t. PVariant'' t => PVariant'' (a t)) => PVariant a
class (forall t. PCovariant'' t => PCovariant'' (a t)) => PCovariant a
class (forall t. PCovariant'' t => PContravariant'' (a t)) => PContravariant a
type PVariant' a :: Constraint
type PCovariant' a :: Constraint
type PContravariant' a :: Constraint
instance forall (a :: Plutarch.Internal.PType -> Plutarch.Internal.PType). (forall (t :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PVariant'' t => Plutarch.Internal.PlutusType.PVariant'' (a t)) => Plutarch.Internal.PlutusType.PVariant a
instance forall (a :: Plutarch.Internal.PType -> Plutarch.Internal.PType). (forall (t :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PCovariant'' t => Plutarch.Internal.PlutusType.PContravariant'' (a t)) => Plutarch.Internal.PlutusType.PContravariant a
instance forall (a :: Plutarch.Internal.PType -> Plutarch.Internal.PType). (forall (t :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PCovariant'' t => Plutarch.Internal.PlutusType.PCovariant'' (a t)) => Plutarch.Internal.PlutusType.PCovariant a
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PCovariant' a => Plutarch.Internal.PlutusType.PCovariant'' a
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PContravariant' a => Plutarch.Internal.PlutusType.PContravariant'' a
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PVariant' a => Plutarch.Internal.PlutusType.PVariant'' a
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (a Plutarch.Internal.:--> b)
instance forall a (f :: a -> Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.Quantification.PForall @a f)
instance forall a (f :: a -> Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.Quantification.PSome @a f)
instance forall (f :: Plutarch.Internal.PType -> Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.Quantification.PFix f)

module Plutarch.Internal.ScottEncoding
data PlutusTypeScott
newtype PScottEncoded a r s
PScottEncoded :: Term s (ScottFn (ScottList a r) r) -> PScottEncoded a r s
instance forall (a :: Plutarch.Internal.PType). (forall (r :: Plutarch.Internal.PType). Plutarch.Internal.ScottEncoding.SListIScottList a r, Data.SOP.Constraint.All @[Plutarch.Internal.PType] (Data.SOP.Constraint.SListI @{Plutarch.Internal.PType}) (Plutarch.Internal.Generic.PCode a), Plutarch.Internal.Generic.PGeneric a) => Plutarch.Internal.ScottEncoding.PlutusTypeScottConstraint a
instance Plutarch.Internal.PlutusType.PlutusTypeStrat Plutarch.Internal.ScottEncoding.PlutusTypeScott
instance forall (a :: Plutarch.Internal.PType) (r :: Plutarch.Internal.PType). Data.SOP.Constraint.SListI @{Plutarch.Internal.PType} (Plutarch.Internal.ScottEncoding.ScottList (Plutarch.Internal.Generic.PCode a) r) => Plutarch.Internal.ScottEncoding.SListIScottList a r
instance forall (a :: [[Plutarch.Internal.PType]]) (r :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.ScottEncoding.PScottEncoded a r)

module Plutarch.Internal.Other

-- | Prettyprint a Term via the PLC pretty printer
--   
--   TODO: Heavily improve. It's unreadable right now.
--   
--   We could convert the de Bruijn indices into names with:
--   
--   <pre>
--   show . prettyPlcReadableDef . (\(Right p) -&gt; p) . Scripts.mkTermToEvaluate . compile $ term
--   </pre>
printTerm :: HasCallStack => Config -> ClosedTerm a -> String

-- | Prettyprint a compiled Script via the PLC pretty printer
printScript :: Script -> String

-- | Safely coerce from a Term to it's <a>PInner</a> representation.
pto :: Term s a -> Term s (PInner a)

-- | Fixpoint recursion. Used to encode recursive functions.
--   
--   Example:
--   
--   <pre>
--   iterateN' ::
--    Term s (PInteger :--&gt; (a :--&gt; a) :--&gt; a :--&gt; a) -&gt;
--    Term s PInteger -&gt;
--    Term s (a :--&gt; a) -&gt;
--    Term s a
--   iterateN' self n f x =
--     pif (n #== 0) x (self # n - 1 #$ f x)
--   
--   iterateN :: Term s (PInteger :--&gt; (a :--&gt; a) :--&gt; a :--&gt; a)
--   iterateN = pfix #$ plam iterateN'
--   </pre>
--   
--   Further examples can be found in examples/Recursion.hs
pfix :: Term s (((a :--> b) :--> (a :--> b)) :--> (a :--> b))

-- | An Arbitrary Term with an unknown type
data POpaque s
POpaque :: Term s POpaque -> POpaque s

-- | Erase the type of a Term
popaque :: Term s a -> Term s POpaque
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Internal.Other.POpaque

module Plutarch.Internal.Newtype
data PlutusTypeNewtype
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Internal.Generic.PGeneric a, (Plutarch.Internal.Generic.PCode a :: [[Plutarch.Internal.PType]]) GHC.Types.~ ((':) @[Plutarch.Internal.PType] ((':) @Plutarch.Internal.PType (Plutarch.Internal.Newtype.GetPNewtype a) ('[] @Plutarch.Internal.PType)) ('[] @[Plutarch.Internal.PType]) :: [[Plutarch.Internal.PType]])) => Plutarch.Internal.Newtype.Helper a
instance Plutarch.Internal.PlutusType.PlutusTypeStrat Plutarch.Internal.Newtype.PlutusTypeNewtype


-- | This module defines functions, associated type families, and newtypes
--   for use with
--   [<tt>DerivingVia</tt>](https:/<i>ryanglscott.github.io</i>papers/deriving-via.pdf)
--   to allow Plutarch to convert to and from PTypes and Haskell types.
module Plutarch.Lift

-- | Create a Plutarch-level constant, from a Haskell value. Example: &gt;
--   pconstant @PInteger 42
pconstant :: forall p s. PLift p => PLifted p -> Term s p

-- | Like <a>plift</a>` but throws on failure.
plift :: forall p. (HasCallStack, PLift p) => ClosedTerm p -> PLifted p

-- | Convert a Plutarch term to the associated Haskell value. Fail
--   otherwise. This will fully evaluate the arbitrary closed expression,
--   and convert the resulting value.
plift' :: forall p. PUnsafeLiftDecl p => Config -> ClosedTerm p -> Either LiftError (PLifted p)

-- | Error during script evaluation.
data LiftError

-- | Class of Haskell types <tt>h</tt> that can be represented as a Plutus
--   core builtin and converted to a Plutarch type.
--   
--   The Plutarch type is determined by `PConstanted h`. Its Plutus Core
--   representation is given by `PConstantRepr h`.
--   
--   This typeclass is closely tied with <a>PLift</a>.
--   
--   Laws: - <tt>pconstantFromRepr . pconstantToRepr ≡ Just</tt> -
--   <tt>(pconstantToRepr <a>$</a>) . pconstantFromRepr ≡ Just</tt> -
--   <tt>plift . pfromData . punsafeCoerce . pconstant . PlutusTx.toData ≡
--   id</tt> - <tt>PlutusTx.fromData . plift . pforgetData . pdata .
--   pconstant ≡ Just</tt>
--   
--   These laws must be upheld for the sake of soundness of the type
--   system.
class (PUnsafeLiftDecl (PConstanted h), DefaultUni `Includes` PConstantRepr h) => PConstantDecl (h :: Type) where {
    type PConstantRepr h :: Type;
    type PConstanted h :: PType;
}
pconstantToRepr :: PConstantDecl h => h -> PConstantRepr h
pconstantFromRepr :: PConstantDecl h => PConstantRepr h -> Maybe h

-- | Class of Plutarch types <tt>p</tt> that can be converted to/from a
--   Haskell type.
--   
--   The Haskell type is determined by `PLifted p`.
--   
--   This typeclass is closely tied with <a>PConstant</a>.
type PLift = PUnsafeLiftDecl

-- | Type synonym to simplify deriving of <tt>PConstant</tt> via
--   <tt>DerivePConstantViaNewtype</tt>.
--   
--   A newtype <tt>Foo a</tt> is considered <a>Constantable</a> if:
--   
--   <ul>
--   <li>The wrapped type <tt>a</tt> has a <tt>PConstant</tt>
--   instance.</li>
--   <li>The lifted type of <tt>a</tt> has a <tt>PUnsafeLiftDecl</tt>
--   instance.</li>
--   <li>There is type equality between <tt>a</tt> and <tt>PLifted
--   (PConstanted a)</tt>.</li>
--   </ul>
--   
--   These constraints are sufficient to derive a <tt>PConstant</tt>
--   instance for the newtype.
--   
--   For deriving <tt>PConstant</tt> for a wrapped type represented in UPLC
--   as <tt>Data</tt>, see <tt>DerivePConstantViaData</tt>.
type PConstant a = (a ~ PLifted (PConstanted a), PConstantDecl a)

-- | Newtype wrapper for deriving <tt>PConstant</tt> when the wrapped type
--   is directly represented by a builtin UPLC type that is <i>not</i>
--   <tt>Data</tt>.
--   
--   Ex: <tt>PInteger</tt> is directly represented as a builtin integer.
newtype DerivePConstantDirect (h :: Type) (p :: PType)
DerivePConstantDirect :: h -> DerivePConstantDirect (h :: Type) (p :: PType)

-- | Newtype wrapper for deriving <tt>PConstant</tt> when the wrapped type
--   is represented indirectly by a builtin UPLC type that is <i>not</i>
--   <tt>Data</tt>.
--   
--   Ex: <tt>PPubKeyHash</tt> is a newtype to a <tt>PByteString</tt> and
--   <tt>PByteString</tt> is directly represented as a builtin bytestring.
--   
--   Polymorphic types can be derived as follows:
--   
--   <pre>
--   newtype Foo a = Foo a
--   
--   newtype PFoo a s = PFoo (Term s a)
--   
--   instance forall a. PLift a =&gt; PUnsafeLiftDecl (PFoo a) where
--     type PLifted (PFoo a) = Foo (PLifted a)
--   
--   deriving via
--     ( DerivePConstantViaNewtype
--         (Foo a)
--         (PFoo (PConstanted a))
--         (PConstanted a)
--     )
--     instance
--       PConstant a =&gt;
--       PConstantDecl (Foo a)
--   </pre>
newtype DerivePConstantViaNewtype (h :: Type) (p :: PType) (p' :: PType)

-- | The Haskell newtype we are deriving a <tt>PConstant</tt> instance for
DerivePConstantViaNewtype :: h -> DerivePConstantViaNewtype (h :: Type) (p :: PType) (p' :: PType)
newtype DerivePConstantViaBuiltin (h :: Type) (p :: PType) (p' :: PType)
DerivePConstantViaBuiltin :: h -> DerivePConstantViaBuiltin (h :: Type) (p :: PType) (p' :: PType)

-- | Laws: - It must be that <tt>PConstantRepr (PLifted p)</tt> when
--   encoded as a constant in UPLC (via the <a>Constant</a> constructor) is
--   a valid <tt>p</tt>.
class (PConstantDecl (PLifted p), PConstanted (PLifted p) ~ p) => PUnsafeLiftDecl (p :: PType) where {
    type PLifted p = (r :: Type) | r -> p;
}
instance GHC.Classes.Eq Plutarch.Lift.LiftError
instance forall (p :: Plutarch.Internal.PType) (p' :: Plutarch.Internal.PType) h h'. (Plutarch.Lift.PLift p, Plutarch.Lift.PLift p', GHC.Types.Coercible @Type h h', Plutarch.Lift.ToBuiltin' (Plutarch.Lift.PLifted p') h', Plutarch.Lift.FromBuiltin' h' (Plutarch.Lift.PLifted p')) => Plutarch.Lift.PConstantDecl (Plutarch.Lift.DerivePConstantViaBuiltin h p p')
instance forall arep a. PlutusTx.Builtins.Class.FromBuiltin arep a => Plutarch.Lift.FromBuiltin' arep a
instance Plutarch.Lift.FromBuiltin' PlutusTx.Builtins.Internal.BuiltinData PlutusCore.Data.Data
instance forall a arep. PlutusTx.Builtins.Class.ToBuiltin a arep => Plutarch.Lift.ToBuiltin' a arep
instance Plutarch.Lift.ToBuiltin' PlutusCore.Data.Data PlutusTx.Builtins.Internal.BuiltinData
instance forall (p :: Plutarch.Internal.PType) (p' :: Plutarch.Internal.PType) h. (Plutarch.Lift.PLift p, Plutarch.Lift.PLift p', GHC.Types.Coercible @Type h (Plutarch.Lift.PLifted p')) => Plutarch.Lift.PConstantDecl (Plutarch.Lift.DerivePConstantViaNewtype h p p')
instance forall (p :: Plutarch.Internal.PType) h. (Plutarch.Lift.PLift p, Universe.Core.Includes @Type PlutusCore.Default.Universe.DefaultUni h) => Plutarch.Lift.PConstantDecl (Plutarch.Lift.DerivePConstantDirect h p)

module Plutarch.Reducible

-- | This class provides a work-around for partially applying type families
--   of kind <tt>a</tt>, where <tt>a</tt> is either <a>Type</a> or <tt>b
--   -&gt; c</tt> where <tt>c</tt> satisfies the same constraint.
--   
--   Given a type family <tt>F : A -&gt; Type</tt>, you can make the
--   following <tt> type F' :: A -&gt; Type newtype F' (a :: A) = F'
--   (NoReduce (F a)) deriving stock Generic </tt> It is then true that
--   <tt>forall a. Reduce (F' a) ~ F a</tt>.
type family Reduce (x :: Type) :: Type
newtype NoReduce a
NoReduce :: a -> NoReduce a
reduce :: Coercible a (Reduce a) => a -> Reduce a

module Plutarch.TryFrom

-- | <tt>PTryFrom a b</tt> represents a subtyping relationship between
--   <tt>a</tt> and <tt>b</tt>, and a way to go from <tt>a</tt> to
--   <tt>b</tt>. Laws: - <tt>(punsafeCoerce . fst) <a>$</a> tcont (ptryFrom
--   x) ≡ pure x</tt>
class PSubtype a b => PTryFrom (a :: PType) (b :: PType) where {
    type PTryFromExcess a b :: PType;
    type PTryFromExcess a b = PTryFromExcess a (PInner b);
}
ptryFrom' :: forall s r. PTryFrom a b => Term s a -> ((Term s b, Reduce (PTryFromExcess a b s)) -> Term s r) -> Term s r
ptryFrom' :: forall s r. (PTryFrom a b, PTryFrom a (PInner b), PTryFromExcess a b ~ PTryFromExcess a (PInner b)) => Term s a -> ((Term s b, Reduce (PTryFromExcess a b s)) -> Term s r) -> Term s r
ptryFrom :: forall b a s r. PTryFrom a b => Term s a -> ((Term s b, Reduce (PTryFromExcess a b s)) -> Term s r) -> Term s r

-- | <tt>PSubtype a b</tt> constitutes a subtyping relation between
--   <tt>a</tt> and <tt>b</tt>. This concretely means that `(x :: Term s b)
--   -&gt; punsafeCoerce x :: Term s a` is legal and sound.
--   
--   You can not make an instance for this yourself. You must use the
--   <a>PInner</a> type family of <tt>PlutusType</tt> to get this instance.
--   
--   Caveat: Only <tt>PInner a POpaque</tt> is considered unfortunately, as
--   otherwise getting GHC to figure out the relation with multiple
--   supertypes is quite hard.
--   
--   Subtyping is transitive.
type family PSubtype (a :: PType) (b :: PType) :: Constraint
type family PSubtype' (a :: PType) (b :: PType) :: Bool
pupcast :: forall a b s. PSubtype a b => Term s b -> Term s a
pupcastF :: forall a b (p :: PType -> PType) s. (PSubtype a b, PCovariant p) => Proxy p -> Term s (p b) -> Term s (p a)
pdowncastF :: forall a b (p :: PType -> PType) s. (PSubtype a b, PContravariant p) => Proxy p -> Term s (p a) -> Term s (p b)

module Plutarch.Unsafe
punsafeBuiltin :: DefaultFun -> Term s a

-- | Unsafely coerce the type-tag of a Term.
--   
--   This should mostly be avoided, though it can be safely used to assert
--   known types of Datums, Redeemers or ScriptContext.
punsafeCoerce :: Term s a -> Term s b

-- | <i>Deprecated: Use <tt>pconstant</tt> instead.</i>
punsafeConstant :: Some (ValueOf DefaultUni) -> Term s a

-- | Unsafely coerce from the <a>PInner</a> representation of a Term,
--   assuming that the value is a safe construction of the Term.
punsafeDowncast :: Term s (PInner a) -> Term s a

module Plutarch.Num
class PNum (a :: PType)
(#+) :: PNum a => Term s a -> Term s a -> Term s a
(#+) :: (PNum a, PNum (PInner a)) => Term s a -> Term s a -> Term s a
(#-) :: PNum a => Term s a -> Term s a -> Term s a
(#-) :: (PNum a, PNum (PInner a)) => Term s a -> Term s a -> Term s a
(#*) :: PNum a => Term s a -> Term s a -> Term s a
(#*) :: (PNum a, PNum (PInner a)) => Term s a -> Term s a -> Term s a
pnegate :: PNum a => Term s (a :--> a)
pnegate :: (PNum a, PNum (PInner a)) => Term s (a :--> a)
pabs :: PNum a => Term s (a :--> a)
pabs :: (PNum a, PNum (PInner a)) => Term s (a :--> a)
psignum :: PNum a => Term s (a :--> a)
psignum :: (PNum a, PNum (PInner a)) => Term s (a :--> a)
pfromInteger :: PNum a => Integer -> Term s a
pfromInteger :: (PNum a, PNum (PInner a)) => Integer -> Term s a
class PFractional (a :: PType)
(#/) :: PFractional a => Term s a -> Term s a -> Term s a
precip :: PFractional a => Term s (a :--> a)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). (Plutarch.Num.PNum a, Plutarch.Num.PFractional a) => GHC.Real.Fractional (Plutarch.Internal.Term s a)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). Plutarch.Num.PNum a => GHC.Num.Num (Plutarch.Internal.Term s a)

module Plutarch.Bool

-- | Plutus <tt>BuiltinBool</tt>
data PBool (s :: S)
PTrue :: PBool (s :: S)
PFalse :: PBool (s :: S)
class PEq t
(#==) :: PEq t => Term s t -> Term s t -> Term s PBool
(#==) :: (PEq t, PGeneric t, PlutusType t, All2 PEq (PCode t)) => Term s t -> Term s t -> Term s PBool
infix 4 #==
class PEq t => POrd t
(#<=) :: POrd t => Term s t -> Term s t -> Term s PBool
(#<=) :: (POrd t, POrd (PInner t)) => Term s t -> Term s t -> Term s PBool
(#<) :: POrd t => Term s t -> Term s t -> Term s PBool
(#<) :: (POrd t, POrd (PInner t)) => Term s t -> Term s t -> Term s PBool
infix 4 #<
infix 4 #<=

-- | Lazy if-then-else.
pif :: Term s PBool -> Term s a -> Term s a -> Term s a

-- | Strict version of <a>pif</a>. Emits slightly less code.
pif' :: Term s (PBool :--> (a :--> (a :--> a)))

-- | Boolean negation for <a>PBool</a> terms.
pnot :: Term s (PBool :--> PBool)

-- | Lazily evaluated boolean and for <a>PBool</a> terms.
(#&&) :: Term s PBool -> Term s PBool -> Term s PBool
infixr 3 #&&

-- | Lazily evaluated boolean or for <a>PBool</a> terms.
(#||) :: Term s PBool -> Term s PBool -> Term s PBool
infixr 2 #||

-- | Hoisted, Plutarch level, lazily evaluated boolean or function.
por :: Term s (PBool :--> (PDelayed PBool :--> PDelayed PBool))

-- | Hoisted, Plutarch level, lazily evaluated boolean and function.
pand :: Term s (PBool :--> (PDelayed PBool :--> PDelayed PBool))

-- | Hoisted, Plutarch level, strictly evaluated boolean and function.
pand' :: Term s (PBool :--> (PBool :--> PBool))

-- | Hoisted, Plutarch level, strictly evaluated boolean or function.
por' :: Term s (PBool :--> (PBool :--> PBool))
instance forall (s :: Plutarch.Internal.S). GHC.Show.Show (Plutarch.Bool.PBool s)
instance Plutarch.Lift.PConstantDecl GHC.Types.Bool
instance Plutarch.Bool.POrd Plutarch.Bool.PBool
instance Plutarch.Bool.PEq Plutarch.Bool.PBool
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Bool.PBool
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Bool.PBool

module Plutarch.Integer

-- | Plutus BuiltinInteger
data PInteger s
class PIntegral a
pdiv :: PIntegral a => Term s (a :--> (a :--> a))
pdiv :: (PIntegral a, PIntegral (PInner a)) => Term s (a :--> (a :--> a))
pmod :: PIntegral a => Term s (a :--> (a :--> a))
pmod :: (PIntegral a, PIntegral (PInner a)) => Term s (a :--> (a :--> a))
pquot :: PIntegral a => Term s (a :--> (a :--> a))
pquot :: (PIntegral a, PIntegral (PInner a)) => Term s (a :--> (a :--> a))
prem :: PIntegral a => Term s (a :--> (a :--> a))
prem :: (PIntegral a, PIntegral (PInner a)) => Term s (a :--> (a :--> a))
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Integer.PInteger
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Integer.PInteger s)
instance Plutarch.Lift.PConstantDecl GHC.Num.Integer.Integer
instance Plutarch.Integer.PIntegral Plutarch.Integer.PInteger
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Integer.PInteger
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Integer.PInteger
instance Plutarch.Bool.PEq Plutarch.Integer.PInteger
instance Plutarch.Bool.POrd Plutarch.Integer.PInteger
instance Plutarch.Num.PNum Plutarch.Integer.PInteger

module Plutarch.ByteString

-- | Plutus <tt>BuiltinByteString</tt>
data PByteString s

-- | Interpret a hex string as a PByteString.
phexByteStr :: HasCallStack => String -> Term s PByteString

-- | Construct a PByteString term from a Haskell bytestring.

-- | <i>Deprecated: Use <a>pconstant</a> instead.</i>
pbyteStr :: ByteString -> Term s PByteString

-- | Prepend a byte, represented by a non negative <a>PInteger</a>, to a
--   <tt>PBytestring</tt>.
pconsBS :: Term s (PInteger :--> (PByteString :--> PByteString))

-- | Slice a <a>PByteString</a> with given start index and slice length.
--   
--   <pre>
--   &gt;&gt;&gt; (pslice # 2 # 3 phexByteStr "4102afde5b2a") #== phexByteStr "afde5b"
--   </pre>
psliceBS :: Term s (PInteger :--> (PInteger :--> (PByteString :--> PByteString)))

-- | Find the length of a <a>PByteString</a>.
plengthBS :: Term s (PByteString :--> PInteger)

-- | <a>PByteString</a> indexing function.
pindexBS :: Term s (PByteString :--> (PInteger :--> PInteger))
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.ByteString.PByteString
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.ByteString.PByteString s)
instance Plutarch.Lift.PConstantDecl Data.ByteString.Internal.ByteString
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.ByteString.PByteString
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.ByteString.PByteString
instance Plutarch.Bool.PEq Plutarch.ByteString.PByteString
instance Plutarch.Bool.POrd Plutarch.ByteString.PByteString
instance forall (s :: Plutarch.Internal.S). GHC.Base.Semigroup (Plutarch.Internal.Term s Plutarch.ByteString.PByteString)
instance forall (s :: Plutarch.Internal.S). GHC.Base.Monoid (Plutarch.Internal.Term s Plutarch.ByteString.PByteString)

module Plutarch.String

-- | Plutus <tt>BuiltinString</tt> values
data PString s

-- | Create a PString from <a>Text</a>

-- | <i>Deprecated: Use <a>pconstant</a> instead.</i>
pfromText :: Text -> Term s PString

-- | Encode a <a>PString</a> using UTF-8.
pencodeUtf8 :: Term s (PString :--> PByteString)

-- | Decode a <a>PByteString</a> using UTF-8.
pdecodeUtf8 :: Term s (PByteString :--> PString)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.String.PString
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.String.PString s)
instance Plutarch.Lift.PConstantDecl Data.Text.Internal.Text
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.String.PString
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.String.PString
instance forall (s :: Plutarch.Internal.S). Data.String.IsString (Plutarch.Internal.Term s Plutarch.String.PString)
instance Plutarch.Bool.PEq Plutarch.String.PString
instance forall (s :: Plutarch.Internal.S). GHC.Base.Semigroup (Plutarch.Internal.Term s Plutarch.String.PString)
instance forall (s :: Plutarch.Internal.S). GHC.Base.Monoid (Plutarch.Internal.Term s Plutarch.String.PString)

module Plutarch.Show
class PShow t

-- | Return the string representation of a Plutarch value
--   
--   If the wrap argument is True, optionally wrap the output in `(..)` if
--   it represents multiple parameters.
pshow' :: PShow t => Bool -> Term s t -> Term s PString

-- | Return the string representation of a Plutarch value
--   
--   If the wrap argument is True, optionally wrap the output in `(..)` if
--   it represents multiple parameters.
pshow' :: (PShow t, PGeneric t, PlutusType t, All2 PShow (PCode t)) => Bool -> Term s t -> Term s PString

-- | Return the string representation of a Plutarch value
pshow :: PShow a => Term s a -> Term s PString
instance Plutarch.Show.PShow Plutarch.String.PString
instance Plutarch.Show.PShow Plutarch.Bool.PBool
instance Plutarch.Show.PShow Plutarch.Integer.PInteger
instance Plutarch.Show.PShow Plutarch.ByteString.PByteString

module Plutarch.Trace

-- | Trace the given message before evaluating the argument.
ptrace :: Term s PString -> Term s a -> Term s a

-- | Like Haskell's <tt>traceShowId</tt> but for Plutarch
ptraceShowId :: PShow a => Term s a -> Term s a

-- | Trace the given message if the argument evaluates to true.
ptraceIfTrue :: Term s PString -> Term s PBool -> Term s PBool

-- | Trace the given message if the argument evaluates to False.
ptraceIfFalse :: Term s PString -> Term s PBool -> Term s PBool

-- | Trace the given message and terminate evaluation with a <a>perror</a>.
ptraceError :: Term s PString -> Term s a

module Plutarch.TermCont
hashOpenTerm :: Term s a -> TermCont s Dig
newtype TermCont :: forall (r :: PType). S -> Type -> Type
[TermCont] :: forall r s a. ((a -> Term s r) -> Term s r) -> TermCont @r s a
runTermCont :: TermCont @r s a -> (a -> Term s r) -> Term s r
unTermCont :: TermCont @a s (Term s a) -> Term s a
tcont :: ((a -> Term s r) -> Term s r) -> TermCont @r s a
instance forall (r :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Base.Functor (Plutarch.TermCont.TermCont @r s)
instance forall (r :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Base.Applicative (Plutarch.TermCont.TermCont @r s)
instance forall (r :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Base.Monad (Plutarch.TermCont.TermCont @r s)
instance forall (r :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). Control.Monad.Fail.MonadFail (Plutarch.TermCont.TermCont @r s)

module Plutarch
data (:-->) (a :: PType) (b :: PType) (s :: S)
infixr 0 :-->

-- | <ul>
--   <li>Closed* terms with no free variables.</li>
--   </ul>
type ClosedTerm (a :: PType) = forall (s :: S). Term s a

-- | Compile a (closed) Plutus Term to a usable script
compile :: Config -> ClosedTerm a -> Either Text Script
type Dig = Digest Blake2b_160
hashTerm :: Config -> ClosedTerm a -> Either Text Dig

-- | Lambda Application.
papp :: HasCallStack => Term s (a :--> b) -> Term s a -> Term s b

-- | Plutus 'delay', used for laziness.
pdelay :: Term s a -> Term s (PDelayed a)
data PDelayed (a :: PType) (s :: S)

-- | Plutus 'error'.
--   
--   When using this explicitly, it should be ensured that the containing
--   term is delayed, avoiding premature evaluation.
perror :: Term s a

-- | Plutus 'force', used to force evaluation of <a>PDelayed</a> terms.
pforce :: Term s (PDelayed a) -> Term s a
phoistAcyclic :: HasCallStack => ClosedTerm a -> Term s a

-- | Let bindings.
--   
--   This is appoximately a shorthand for a lambda and application:
--   
--   <tt>plet v f</tt> == <tt> papp (plam f) v</tt>
--   
--   But sufficiently small terms in WHNF may be inlined for efficiency.
plet :: Term s a -> (Term s a -> Term s b) -> Term s b
data Term (s :: S) (a :: PType)
data S

-- | Shorthand for Plutarch types.
type PType = S -> Type
class PlutusType (a :: PType)
type PInner a :: PType

-- | Construct a Plutarch Term via a Haskell datatype
pcon :: PlutusType a => a s -> Term s a

-- | Pattern match over Plutarch Terms via a Haskell datatype
pmatch :: PlutusType a => Term s a -> (a s -> Term s b) -> Term s b

-- | <i>Deprecated: Use PlutusType</i>
type PCon = PlutusType

-- | <i>Deprecated: Use PlutusType</i>
type PMatch = PlutusType

-- | Prettyprint a Term via the PLC pretty printer
--   
--   TODO: Heavily improve. It's unreadable right now.
--   
--   We could convert the de Bruijn indices into names with:
--   
--   <pre>
--   show . prettyPlcReadableDef . (\(Right p) -&gt; p) . Scripts.mkTermToEvaluate . compile $ term
--   </pre>
printTerm :: HasCallStack => Config -> ClosedTerm a -> String

-- | Prettyprint a compiled Script via the PLC pretty printer
printScript :: Script -> String

-- | Low precedence infixr synonym of <a>papp</a>, to be used like
--   <a>$</a>, in combination with <a>#</a>. e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; f # x #$ g # y # z
--   f x (g y z)
--   </pre>
(#$) :: HasCallStack => Term s (a :--> b) -> Term s a -> Term s b
infixr 0 #$

-- | High precedence infixl synonym of <a>papp</a>, to be used like
--   function juxtaposition. e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; f # x # y
--   f x y
--   </pre>
(#) :: HasCallStack => Term s (a :--> b) -> Term s a -> Term s b
infixl 8 #
pinl :: Term s a -> (Term s a -> Term s b) -> Term s b

-- | Safely coerce from a Term to it's <a>PInner</a> representation.
pto :: Term s a -> Term s (PInner a)

-- | Fixpoint recursion. Used to encode recursive functions.
--   
--   Example:
--   
--   <pre>
--   iterateN' ::
--    Term s (PInteger :--&gt; (a :--&gt; a) :--&gt; a :--&gt; a) -&gt;
--    Term s PInteger -&gt;
--    Term s (a :--&gt; a) -&gt;
--    Term s a
--   iterateN' self n f x =
--     pif (n #== 0) x (self # n - 1 #$ f x)
--   
--   iterateN :: Term s (PInteger :--&gt; (a :--&gt; a) :--&gt; a :--&gt; a)
--   iterateN = pfix #$ plam iterateN'
--   </pre>
--   
--   Further examples can be found in examples/Recursion.hs
pfix :: Term s (((a :--> b) :--> (a :--> b)) :--> (a :--> b))

-- | An Arbitrary Term with an unknown type
data POpaque s
POpaque :: Term s POpaque -> POpaque s

-- | Erase the type of a Term
popaque :: Term s a -> Term s POpaque
plam :: forall c. PLamN a b s => (Term s c -> a) -> Term s (c :--> b)
newtype TermCont :: forall (r :: PType). S -> Type -> Type
[TermCont] :: forall r s a. ((a -> Term s r) -> Term s r) -> TermCont @r s a
hashOpenTerm :: Term s a -> TermCont s Dig
runTermCont :: TermCont @r s a -> (a -> Term s r) -> Term s r
unTermCont :: TermCont @a s (Term s a) -> Term s a
data Config
Config :: TracingMode -> Config
[tracingMode] :: Config -> TracingMode
data TracingMode
NoTracing :: TracingMode
DoTracing :: TracingMode
DetTracing :: TracingMode
pgetConfig :: (Config -> Term s a) -> Term s a
defaultConfig :: Config
newtype PForall (b :: a -> PType) s
PForall :: (forall (x :: a). Term s (b x)) -> PForall (b :: a -> PType) s
data PSome (b :: a -> PType) s
PSome :: Term s (b x) -> PSome (b :: a -> PType) s
newtype PScottEncoded a r s
PScottEncoded :: Term s (ScottFn (ScottList a r) r) -> PScottEncoded a r s
data PlutusTypeScott
data PlutusTypeNewtype
class (PInner a ~ DerivedPInner (DPTStrat a) a, PlutusTypeStrat (DPTStrat a), PlutusTypeStratConstraint (DPTStrat a) a, PlutusType a) => DerivePlutusType (a :: PType)
type DPTStrat a :: Type
class (forall t. PCovariant'' t => PCovariant'' (a t)) => PCovariant a
type PCovariant' a :: Constraint
class (forall t. PCovariant'' t => PContravariant'' (a t)) => PContravariant a
type PContravariant' a :: Constraint
class (forall t. PVariant'' t => PVariant'' (a t)) => PVariant a
type PVariant' a :: Constraint

module Plutarch.Unit
data PUnit s
PUnit :: PUnit s
instance Plutarch.Lift.PConstantDecl ()
instance Plutarch.Lift.PUnsafeLiftDecl (Plutarch.Unit.PUnit @{Plutarch.Internal.S})
instance Plutarch.Internal.PlutusType.PlutusType (Plutarch.Unit.PUnit @{Plutarch.Internal.S})
instance Plutarch.Bool.PEq (Plutarch.Unit.PUnit @{Plutarch.Internal.S})
instance Plutarch.Bool.POrd (Plutarch.Unit.PUnit @{Plutarch.Internal.S})
instance forall (s :: Plutarch.Internal.S). GHC.Base.Semigroup (Plutarch.Internal.Term s (Plutarch.Unit.PUnit @{Plutarch.Internal.S}))
instance forall (s :: Plutarch.Internal.S). GHC.Base.Monoid (Plutarch.Internal.Term s (Plutarch.Unit.PUnit @{Plutarch.Internal.S}))
instance Plutarch.Show.PShow (Plutarch.Unit.PUnit @{Plutarch.Internal.S})

module Plutarch.Pair

-- | Plutus encoding of Pairs.
--   
--   Note: This is represented differently than <tt>BuiltinPair</tt>. It is
--   scott-encoded.
data PPair (a :: PType) (b :: PType) (s :: S)
PPair :: Term s a -> Term s b -> PPair (a :: PType) (b :: PType) (s :: S)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). (Plutarch.Show.PShow a, Plutarch.Show.PShow b) => Plutarch.Show.PShow (Plutarch.Pair.PPair a b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). (Plutarch.Bool.PEq a, Plutarch.Bool.PEq b) => Plutarch.Bool.PEq (Plutarch.Pair.PPair a b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Pair.PPair a b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Pair.PPair a b s)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Pair.PPair a b)

module Plutarch.Maybe

-- | Plutus Maybe type, with Scott-encoded repr
data PMaybe (a :: PType) (s :: S)
PJust :: Term s a -> PMaybe (a :: PType) (s :: S)
PNothing :: PMaybe (a :: PType) (s :: S)

-- | fallible unwrapping from <tt>PMaybe</tt>
pfromJust :: Term s (PMaybe a :--> a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Show.PShow a => Plutarch.Show.PShow (Plutarch.Maybe.PMaybe a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Bool.PEq a => Plutarch.Bool.PEq (Plutarch.Maybe.PMaybe a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Maybe.PMaybe a)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Maybe.PMaybe a s)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Maybe.PMaybe a)


-- | Scott-encoded lists and ListLike typeclass
module Plutarch.List
data PList (a :: PType) (s :: S)
PSCons :: Term s a -> Term s (PList a) -> PList (a :: PType) (s :: S)
PSNil :: PList (a :: PType) (s :: S)

-- | Plutarch types that behave like lists.
class PListLike (list :: (PType) -> PType) where {
    type PElemConstraint list (a :: PType) :: Constraint;
}

-- | Canonical eliminator for list-likes.
pelimList :: (PListLike list, PElemConstraint list a) => (Term s a -> Term s (list a) -> Term s r) -> Term s r -> Term s (list a) -> Term s r

-- | Cons an element onto an existing list.
pcons :: (PListLike list, PElemConstraint list a) => Term s (a :--> (list a :--> list a))

-- | The empty list
pnil :: (PListLike list, PElemConstraint list a) => Term s (list a)

-- | Return the first element of a list. Partial, throws an error upon
--   encountering an empty list.
phead :: (PListLike list, PElemConstraint list a) => Term s (list a :--> a)

-- | Take the tail of a list, meaning drop its head. Partial, throws an
--   error upon encountering an empty list.
ptail :: (PListLike list, PElemConstraint list a) => Term s (list a :--> list a)

-- | <i> O(1) </i>. Check if a list is empty
pnull :: (PListLike list, PElemConstraint list a) => Term s (list a :--> PBool)

-- | 'PIsListLike list a' constraints <tt>list</tt> be a <a>PListLike</a>
--   with valid element type, <tt>a</tt>.
type PIsListLike list a = (PListLike list, PElemConstraint list a)

-- | <i> O(n) </i>. Convert from any ListLike to any ListLike, provided
--   both lists' element constraints are met.
pconvertLists :: forall f g a s. (PIsListLike f a, PIsListLike g a) => Term s (f a :--> g a)
pshowList :: forall list a s. (PShow a, PIsListLike list a) => Term s (list a :--> PString)

-- | <i> O(min(n, m)) </i>. Check if two lists are equal.
plistEquals :: (PIsListLike list a, PEq a) => Term s (list a :--> (list a :--> PBool))

-- | <i> O(n) </i>. Check if element is in the list
pelem :: (PIsListLike list a, PEq a) => Term s (a :--> (list a :--> PBool))

-- | <i> O(n) </i>. Count the number of elements in the list
plength :: PIsListLike list a => Term s (list a :--> PInteger)

-- | Index a BuiltinList, throwing an error if the index is out of bounds.
ptryIndex :: PIsListLike list a => Natural -> Term s (list a) -> Term s a

-- | Drop the first n fields of a List.
--   
--   The term will be statically generated as repeated applications of
--   <a>ptail</a>, which will be more efficient in many circumstances.
pdrop :: PIsListLike list a => Natural -> Term s (list a) -> Term s (list a)

-- | <i> O(n) </i>. like haskell level <tt>find</tt> but on plutarch level
pfind :: PIsListLike l a => Term s ((a :--> PBool) :--> (l a :--> PMaybe a))

-- | <i> O(n) </i>. Like Haskell level <a>(!!)</a> but on the Plutarch
--   level, not infix and with arguments reversed, errors if the specified
--   index is greater than or equal to the lists length
pelemAt :: PIsListLike l a => Term s (PInteger :--> (l a :--> a))

-- | <i> O(n) </i>. Like Haskell level <a>(!!)</a> but on the plutarch
--   level
(#!!) :: PIsListLike l a => Term s (l a) -> Term s PInteger -> Term s a

-- | <i> O(1) </i>. Create a singleton list from an element
psingleton :: PIsListLike list a => Term s (a :--> list a)

-- | Extract head and tail of the list, if list is not empty.
puncons :: PIsListLike list a => Term s (list a :--> PMaybe (PPair a (list a)))

-- | Extract head and tail of the list, throws error if list is empty.
ptryUncons :: PIsListLike list a => Term s (list a :--> PPair a (list a))

-- | <i> O(n) </i>. Concatenate two lists
--   
--   Example: &gt; pconcat # psingleton x # psingleton y == plistLiteral
--   [x, y]
--   
--   pconcat exhibits identities with empty lists such that &gt; forall x.
--   pconcat # pnil # x == x &gt; forall x. pconcat # x # pnil == x
pconcat :: PIsListLike list a => Term s (list a :--> (list a :--> list a))

-- | <i> O(min(n, m)) </i>. Zip two lists together with a passed function.
--   
--   If the lists are of differing lengths, cut to the shortest.
pzipWith :: (PListLike list, PElemConstraint list a, PElemConstraint list b, PElemConstraint list c) => Term s ((a :--> (b :--> c)) :--> (list a :--> (list b :--> list c)))

-- | Like <a>pzipWith</a> but with Haskell-level merge function.
pzipWith' :: (PListLike list, PElemConstraint list a, PElemConstraint list b, PElemConstraint list c) => (Term s a -> Term s b -> Term s c) -> Term s (list a :--> (list b :--> list c))

-- | <i> O(min(n, m)) </i>. Zip two lists together, creating pairs of the
--   elements.
--   
--   If the lists are of differing lengths, cut to the shortest.
pzip :: (PListLike list, PElemConstraint list a, PElemConstraint list b, PElemConstraint list (PPair a b)) => Term s (list a :--> (list b :--> list (PPair a b)))

-- | <i> O(n) </i>. Map a function over a list of elements
pmap :: (PListLike list, PElemConstraint list a, PElemConstraint list b) => Term s ((a :--> b) :--> (list a :--> list b))

-- | <i> O(n) </i>. Filter elements from a list that don't match the
--   predicate.
pfilter :: PIsListLike list a => Term s ((a :--> PBool) :--> (list a :--> list a))

-- | Like <a>pelimList</a>, but with a fixpoint recursion hatch.
precList :: PIsListLike list a => (Term s (list a :--> r) -> Term s a -> Term s (list a) -> Term s r) -> (Term s (list a :--> r) -> Term s r) -> Term s (list a :--> r)

-- | <i> O(n) </i>. Fold on a list right-associatively.
pfoldr :: PIsListLike list a => Term s ((a :--> (b :--> b)) :--> (b :--> (list a :--> b)))

-- | The same as <a>pfoldr'</a>, but with Haskell-level reduction function.
pfoldr' :: PIsListLike list a => (forall s. Term s a -> Term s b -> Term s b) -> Term s (b :--> (list a :--> b))

-- | <i> O(n) </i>. Fold on a list right-associatively, with opportunity
--   for short circuting.
--   
--   May short circuit when given reducer function is lazy in its second
--   argument.
pfoldrLazy :: PIsListLike list a => Term s ((a :--> (PDelayed b :--> b)) :--> (b :--> (list a :--> b)))

-- | <i> O(n) </i>. Fold on a list left-associatively.
pfoldl :: PIsListLike list a => Term s ((b :--> (a :--> b)) :--> (b :--> (list a :--> b)))

-- | The same as <a>pfoldl</a>, but with Haskell-level reduction function.
pfoldl' :: PIsListLike list a => (forall s. Term s b -> Term s a -> Term s b) -> Term s (b :--> (list a :--> b))

-- | <i> O(n) </i>. Check that predicate holds for all elements in a list.
pall :: PIsListLike list a => Term s ((a :--> PBool) :--> (list a :--> PBool))

-- | <i> O(n) </i>. Check that predicate holds for any element in a list.
pany :: PIsListLike list a => Term s ((a :--> PBool) :--> (list a :--> PBool))
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.List.PList a)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.List.PList a s)
instance Plutarch.List.PListLike Plutarch.List.PList
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.List.PList a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Show.PShow a => Plutarch.Show.PShow (Plutarch.List.PList a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Bool.PEq a => Plutarch.Bool.PEq (Plutarch.List.PList a)

module Plutarch.Either
data PEither (a :: PType) (b :: PType) (s :: S)
PLeft :: Term s a -> PEither (a :: PType) (b :: PType) (s :: S)
PRight :: Term s b -> PEither (a :: PType) (b :: PType) (s :: S)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). (Plutarch.Show.PShow a, Plutarch.Show.PShow b) => Plutarch.Show.PShow (Plutarch.Either.PEither a b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). (Plutarch.Bool.PEq a, Plutarch.Bool.PEq b) => Plutarch.Bool.PEq (Plutarch.Either.PEither a b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Either.PEither a b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Either.PEither a b s)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Either.PEither a b)

module Plutarch.Crypto

-- | Hash a <a>PByteString</a> using SHA-256.
psha2_256 :: Term s (PByteString :--> PByteString)

-- | Hash a <a>PByteString</a> using SHA3-256.
psha3_256 :: Term s (PByteString :--> PByteString)

-- | Hash a <a>PByteString</a> using Blake2B-256.
pblake2b_256 :: Term s (PByteString :--> PByteString)

-- | Verify the signature against the public key and message.
pverifySignature :: Term s (PByteString :--> (PByteString :--> (PByteString :--> PBool)))

module Plutarch.Builtin
data PData (s :: S)
pfstBuiltin :: Term s (PBuiltinPair a b :--> a)
psndBuiltin :: Term s (PBuiltinPair a b :--> b)
pasConstr :: Term s (PData :--> PBuiltinPair PInteger (PBuiltinList PData))
pasMap :: Term s (PData :--> PBuiltinList (PBuiltinPair PData PData))
pasList :: Term s (PData :--> PBuiltinList PData)
pasInt :: Term s (PData :--> PInteger)

-- | Create a Plutarch-level <a>PAsData</a> constant, from a Haskell value.
--   Example: &gt; pconstantData @PInteger 42
pconstantData :: forall p h s. (ToData h, PLifted p ~ h, PConstanted h ~ p) => h -> Term s (PAsData p)
pconstrBuiltin :: Term s (PInteger :--> (PBuiltinList PData :--> PAsData (PBuiltinPair PInteger (PBuiltinList PData))))
pasByteStr :: Term s (PData :--> PByteString)

-- | Plutus <tt>BuiltinPair</tt>
data PBuiltinPair (a :: PType) (b :: PType) (s :: S)

-- | Plutus <tt>BuiltinList</tt>
data PBuiltinList (a :: PType) (s :: S)
PCons :: Term s a -> Term s (PBuiltinList a) -> PBuiltinList (a :: PType) (s :: S)
PNil :: PBuiltinList (a :: PType) (s :: S)

-- | <i>Deprecated: Use <a>pconstant</a> instead.</i>
pdataLiteral :: Data -> Term s PData

-- | Laws: - If <tt>PSubtype PData a</tt>, then <tt>pdataImpl a</tt> must
--   be <a>pupcast</a>. - pdataImpl . pupcast . pfromDataImpl ≡ id -
--   pfromDataImpl . punsafeDowncast . pdataImpl ≡ id
class PIsData a
pfromDataImpl :: PIsData a => Term s (PAsData a) -> Term s a
pfromDataImpl :: (PIsData a, PIsData (PInner a)) => Term s (PAsData a) -> Term s a
pdataImpl :: PIsData a => Term s a -> Term s PData
pdataImpl :: (PIsData a, PIsData (PInner a)) => Term s a -> Term s PData
pdata :: PIsData a => Term s a -> Term s (PAsData a)
pfromData :: PIsData a => Term s (PAsData a) -> Term s a
data PAsData (a :: PType) (s :: S)
pforgetData :: forall s a. Term s (PAsData a) -> Term s PData

-- | Inverse of <a>pforgetData'</a>.
prememberData :: forall (p :: PType -> PType) s. PVariant p => Proxy p -> Term s (p PData) -> Term s (p (PAsData PData))

-- | Like <a>prememberData</a> but generalised.
prememberData' :: forall a (p :: PType -> PType) s. (PSubtype PData a, PVariant p) => Proxy p -> Term s (p a) -> Term s (p (PAsData a))

-- | Construct a builtin pair of <a>PData</a> elements.
--   
--   Uses <a>PAsData</a> to preserve more information about the underlying
--   <a>PData</a>.
ppairDataBuiltin :: Term s (PAsData a :--> (PAsData b :--> PBuiltinPair (PAsData a) (PAsData b)))
pchooseListBuiltin :: Term s (PBuiltinList a :--> (b :--> (b :--> b)))

-- | Map type used for Plutus <a>Data</a>'s Map constructor.
--   
--   Note that the Plutus API doesn't use this most of the time, instead
--   encoding as a List of Tuple constructors.
--   
--   Not to be confused with <a>Map</a> / <tt>PMap</tt>
type PBuiltinMap a b = (PBuiltinList (PBuiltinPair (PAsData a) (PAsData b)))
instance forall k (f :: k -> Plutarch.Internal.PType) (a :: k). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Builtin.Helper2 @{k} f a)
instance forall k (f :: k -> Plutarch.Internal.PType) (a :: k) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Builtin.Helper2 @{k} f a s)
instance forall k1 k2 (f :: k2 -> k1 -> Plutarch.Internal.PType) (b :: k1) (a :: k2). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Builtin.Helper3 @{k2} @{k1} f b a)
instance forall k1 k2 (f :: k2 -> k1 -> Plutarch.Internal.PType) (b :: k1) (a :: k2) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Builtin.Helper3 @{k2} @{k1} f b a s)
instance forall k1 k2 (f :: k2 -> k1 -> Plutarch.Internal.PType) (b :: k1) (a :: k2). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Builtin.Helper4 @{k2} @{k1} f b a)
instance forall k1 k2 (f :: k2 -> k1 -> Plutarch.Internal.PType) (b :: k1) (a :: k2) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Builtin.Helper4 @{k2} @{k1} f b a s)
instance forall k1 k2 (f :: k2 -> k1 -> Type) (a :: k1) (b :: k2). GHC.Generics.Generic (Plutarch.Builtin.Flip @{k2} @{k1} f a b)
instance Plutarch.Lift.PConstantDecl PlutusCore.Data.Data
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.Integer.PInteger)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.ByteString.PByteString)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). (Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData a), Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData b)) => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.Builtin.PBuiltinMap a b))
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.Builtin.PBuiltinList Plutarch.Builtin.PData))
instance forall (a :: Plutarch.Internal.PType). (Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData a), Plutarch.Builtin.PIsData a) => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.Builtin.PBuiltinList (Plutarch.Builtin.PAsData a)))
instance forall (a :: Plutarch.Internal.PType) (a' :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType) (b' :: Plutarch.Internal.PType). (Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData a, (a :: Plutarch.Internal.PType) GHC.Types.~ (Plutarch.Builtin.PAsData a' :: Plutarch.Internal.PType), Plutarch.Builtin.PIsData a', Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData b, (b :: Plutarch.Internal.PType) GHC.Types.~ (Plutarch.Builtin.PAsData b' :: Plutarch.Internal.PType), Plutarch.Builtin.PIsData b') => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.Builtin.PBuiltinPair a b))
instance forall k1 k2 (f :: k1 -> k2 -> Plutarch.Internal.PType) (b :: k2) (a :: k1). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Builtin.Helper4 @{k1} @{k2} f b a)
instance Plutarch.Builtin.PIsData (Plutarch.Builtin.PBuiltinPair Plutarch.Builtin.PData Plutarch.Builtin.PData)
instance forall k1 k2 (f :: k1 -> k2 -> Plutarch.Internal.PType) (b :: k2) (a :: k1). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Builtin.Helper3 @{k1} @{k2} f b a)
instance forall k (f :: k -> Plutarch.Internal.PType) (a :: k). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Builtin.Helper2 @{k} f a)
instance Plutarch.Builtin.PIsData (Plutarch.Builtin.PBuiltinList Plutarch.Builtin.PData)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Builtin.PIsData (Plutarch.Builtin.PBuiltinList a) => Plutarch.Builtin.Fc 'GHC.Types.True a
instance forall (a :: Plutarch.Internal.PType). Plutarch.Builtin.PIsData a => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Builtin.PAsData a)
instance Plutarch.Builtin.PIsData Plutarch.Builtin.PData
instance forall (a :: Plutarch.Internal.PType). Plutarch.Builtin.PIsData (Plutarch.Builtin.PBuiltinList (Plutarch.Builtin.PAsData a))
instance forall (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType). Plutarch.Builtin.PIsData (Plutarch.Builtin.PBuiltinMap k v)
instance Plutarch.Builtin.PIsData Plutarch.Integer.PInteger
instance Plutarch.Builtin.PIsData Plutarch.ByteString.PByteString
instance Plutarch.Builtin.PIsData Plutarch.Bool.PBool
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). Plutarch.Builtin.PIsData (Plutarch.Builtin.PBuiltinPair (Plutarch.Builtin.PAsData a) (Plutarch.Builtin.PAsData b))
instance Plutarch.Builtin.PIsData (Plutarch.Unit.PUnit @{Plutarch.Internal.S})
instance Plutarch.Builtin.PIsData (Plutarch.Builtin.PBuiltinPair Plutarch.Integer.PInteger (Plutarch.Builtin.PBuiltinList Plutarch.Builtin.PData))
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Builtin.PIsData a, Plutarch.Show.PShow a) => Plutarch.Show.PShow (Plutarch.Builtin.PAsData a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Lift.PConstantDecl (Plutarch.Builtin.PAsDataLifted a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Lift.PUnsafeLiftDecl (Plutarch.Builtin.PAsData a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Builtin.Fc (Plutarch.Builtin.F a) a => Plutarch.Bool.PEq (Plutarch.Builtin.PBuiltinList a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Bool.PEq (Plutarch.Builtin.PAsData a)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.Builtin.PData)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Builtin.PData
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Builtin.PData
instance Plutarch.Bool.PEq Plutarch.Builtin.PData
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Lift.PLift a, Plutarch.Bool.PEq a) => Plutarch.Builtin.Fc 'GHC.Types.False a
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Show.PShow a, Plutarch.Lift.PLift a) => Plutarch.Show.PShow (Plutarch.Builtin.PBuiltinList a)
instance forall a. Plutarch.Lift.PConstant a => Plutarch.Lift.PConstantDecl [a]
instance forall (a :: Plutarch.Internal.PType). Plutarch.Lift.PUnsafeLiftDecl a => Plutarch.Lift.PUnsafeLiftDecl (Plutarch.Builtin.PBuiltinList a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Lift.PLift a => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Builtin.PBuiltinList a)
instance Plutarch.List.PListLike Plutarch.Builtin.PBuiltinList
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Builtin.PBuiltinPair a b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). (Plutarch.Lift.PLift a, Plutarch.Lift.PLift b) => Plutarch.Lift.PUnsafeLiftDecl (Plutarch.Builtin.PBuiltinPair a b)
instance forall a b. (Plutarch.Lift.PConstant a, Plutarch.Lift.PConstant b) => Plutarch.Lift.PConstantDecl (a, b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). (Plutarch.Show.PShow a, Plutarch.Show.PShow b) => Plutarch.Show.PShow (Plutarch.Builtin.PBuiltinPair a b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). (Plutarch.Bool.PEq a, Plutarch.Bool.PEq b) => Plutarch.Bool.PEq (Plutarch.Builtin.PBuiltinPair a b)

module Plutarch.Rational
data PRational s
PRational :: Term s PInteger -> Term s PInteger -> PRational s
preduce :: Term s (PRational :--> PRational)
pnumerator :: Term s (PRational :--> PInteger)
pdenominator :: Term s (PRational :--> PInteger)
pfromInteger :: Term s (PInteger :--> PRational)
pround :: Term s (PRational :--> PInteger)
ptruncate :: Term s (PRational :--> PInteger)
pproperFraction :: Term s (PRational :--> PPair PInteger PRational)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Rational.PRational
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Rational.PRational s)
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Rational.PRational
instance Plutarch.Show.PShow Plutarch.Rational.PRational
instance Plutarch.Builtin.PIsData Plutarch.Rational.PRational
instance Plutarch.Bool.PEq Plutarch.Rational.PRational
instance Plutarch.Bool.POrd Plutarch.Rational.PRational
instance Plutarch.Num.PNum Plutarch.Rational.PRational
instance Plutarch.Num.PFractional Plutarch.Rational.PRational

module Plutarch.FFI

-- | Equality of inner types - Plutarch on the left and Haskell on the
--   right.
type family (p :: PType) >~< (t :: Type) :: Constraint

-- | Plutarch type of lists compatible with the PlutusTx encoding of
--   Haskell lists and convertible with the regular <a>PList</a> using
--   <a>plistToTx</a> and <a>plistFromTx</a>.
data PTxList (a :: PType) (s :: S)
PTxCons :: Term s a -> Term s (PTxList a) -> PTxList (a :: PType) (s :: S)
PTxNil :: PTxList (a :: PType) (s :: S)

-- | Plutarch type compatible with the PlutusTx encoding of Haskell
--   <a>Maybe</a> and convertible with the regular <a>PMaybe</a> using
--   <a>pmaybeToTx</a> and <a>pmaybeFromTx</a>.
data PTxMaybe (a :: PType) (s :: S)
PTxJust :: Term s a -> PTxMaybe (a :: PType) (s :: S)
PTxNothing :: PTxMaybe (a :: PType) (s :: S)

-- | Compile and export a Plutarch term so it can be used by
--   <a>applyCode</a>.
foreignExport :: forall p t. p >~< t => Config -> ClosedTerm p -> CompiledCode t

-- | Import compiled UPLC code (such as a spliced <a>compile</a> result) as
--   a Plutarch term.
foreignImport :: forall p t. p >~< t => CompiledCode t -> ClosedTerm p

-- | Export Plutarch term of any type as <tt>CompiledCode Void</tt>.
opaqueExport :: Config -> ClosedTerm p -> CompiledCode Void

-- | Import compiled UPLC code of any type as a Plutarch opaque term.
opaqueImport :: CompiledCode t -> ClosedTerm POpaque

-- | Convert a <a>PTxList</a> to a <a>PList</a>, probably after importing
--   it with <a>foreignImport</a>.
plistFromTx :: Term s (PTxList a :--> PList a)

-- | Convert a <a>PList</a> to a <a>PTxList</a>, perhaps before exporting
--   it with <a>foreignExport</a>.
plistToTx :: Term s (PList a :--> PTxList a)

-- | Convert a <a>PTxMaybe</a> to a <a>PMaybe</a>, probably after importing
--   it with <a>foreignImport</a>.
pmaybeFromTx :: Term s (PTxMaybe a :--> PMaybe a)

-- | Convert a <a>PMaybe</a> to a <a>PTxMaybe</a>, perhaps before exporting
--   it with <a>foreignExport</a>.
pmaybeToTx :: Term s (PMaybe a :--> PTxMaybe a)

-- | Seriously unsafe, may fail at run time or result in unexpected
--   behaviour in your on-chain validator.
unsafeForeignExport :: Config -> ClosedTerm p -> CompiledCode t

-- | Seriously unsafe, may fail at run time or result in unexpected
--   behaviour in your on-chain validator.
unsafeForeignImport :: CompiledCode t -> ClosedTerm p
instance forall (a :: Plutarch.Internal.PType). Plutarch.Show.PShow a => Plutarch.Show.PShow (Plutarch.FFI.PTxList a)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). Generics.SOP.Universe.HasDatatypeInfo (Plutarch.FFI.PTxList a s)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). Generics.SOP.Universe.Generic (Plutarch.FFI.PTxList a s)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.FFI.PTxList a s)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Show.PShow a => Plutarch.Show.PShow (Plutarch.FFI.PTxMaybe a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Bool.PEq a => Plutarch.Bool.PEq (Plutarch.FFI.PTxMaybe a)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). Generics.SOP.Universe.HasDatatypeInfo (Plutarch.FFI.PTxMaybe a s)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). Generics.SOP.Universe.Generic (Plutarch.FFI.PTxMaybe a s)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.FFI.PTxMaybe a s)
instance forall (a :: Plutarch.Internal.PType) (r :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.FFI.PTxList' a r)
instance forall (a :: Plutarch.Internal.PType) (r :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.FFI.PTxList' a r s)
instance forall (a :: Plutarch.Internal.PType) (r :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.FFI.PTxMaybe' a r)
instance forall (a :: Plutarch.Internal.PType) (r :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.FFI.PTxMaybe' a r s)
instance forall (a :: Plutarch.Internal.PType) (r :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.FFI.PTxMaybe' a r)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.FFI.PTxMaybe a)
instance forall (a :: Plutarch.Internal.PType) (r :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.FFI.PTxList' a r)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.FFI.PTxList a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Bool.PEq a => Plutarch.Bool.PEq (Plutarch.FFI.PTxList a)
instance Plutarch.List.PListLike Plutarch.FFI.PTxList

module Plutarch.DataRepr.Internal.FromData

-- | removes the PAsData if the hole requires it but leaves it there if it
--   doesn't
--   
--   <pre>
--   &gt;&gt;&gt; :t pmaybeFromAsData (pdata 3 :: (Term s (PAsData PInteger))) :: (Term (s::S) PInteger)
--   pmaybeFromAsData (pdata 3 :: (Term s (PAsData PInteger))) :: (Term (s::S) PInteger)
--   :: forall (s :: S). Term s (PInteger @{S})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t pmaybeFromAsData (pdata 3 :: (Term s (PAsData PInteger))) :: (Term (s::S) (PAsData PInteger))
--   pmaybeFromAsData (pdata 3 :: (Term s (PAsData PInteger))) :: (Term (s::S) (PAsData PInteger))
--   :: forall (s :: S). Term s (PAsData (PInteger @{S}))
--   </pre>
class PFromDataable (a :: PType) (b :: PType) | b -> a, a -> b
pmaybeFromAsData :: PFromDataable a b => Term s (PAsData a) -> Term s b
instance forall (a :: Plutarch.Internal.PType). Plutarch.DataRepr.Internal.FromData.PFromDataable a (Plutarch.Builtin.PAsData a)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). (Plutarch.Builtin.PIsData a, (b :: Plutarch.Internal.PType) GHC.Types.~ (a :: Plutarch.Internal.PType)) => Plutarch.DataRepr.Internal.FromData.PFromDataable a b

module Plutarch.DataRepr.Internal.HList
data HRec as
[HNil] :: HRec '[]
[HCons] :: Labeled name a -> HRec as -> HRec ('(name, a) : as)
newtype HRecGeneric as
HRecGeneric :: HRec as -> HRecGeneric as
newtype Labeled sym a
Labeled :: a -> Labeled sym a
[unLabeled] :: Labeled sym a -> a

-- | Index a <a>HRec</a> with a field in a provided list of data fields.
--   Implicitly unwraps `PAsData a` to <tt>a</tt> when necessary.
--   
--   <pre>
--   &gt;&gt;&gt; xs = HRec @["x", "y", "z"] (HCons 1 (HCons 2 (HCons 3 HNil)))
--   
--   &gt;&gt;&gt; hrecField @"y" @["x", "y", "z"] xs
--   
--   &gt;&gt;&gt; 2
--   </pre>
hrecField :: forall name a as b c s. (ElemOf name a as, Term s (PAsData b) ~ a, PFromDataable b c) => HRec as -> Term s c

-- | Index a HList with a field in a provided list of fields.
--   
--   <pre>
--   &gt;&gt;&gt; xs = HRec @["x", "y", "z"] (HCons 1 (HCons 2 (HCons 3 HNil)))
--   
--   &gt;&gt;&gt; hrecField @"y" @["x", "y", "z"] xs
--   
--   &gt;&gt;&gt; 2
--   </pre>
hrecField' :: forall name a as. ElemOf name a as => HRec as -> a

-- | Indexing type-level lists
type family IndexList (n :: Nat) (l :: [k]) :: k

-- | Indexing list of labeled pairs by label
type family IndexLabel name as

-- | Return the single item from a singleton list
type family SingleItem (as :: [k]) :: k

-- | Drop first n fields of a list
type family Drop (n :: Nat) (as :: [k]) :: [k]

-- | GADT proof-witness of HList membership, usable as an index
data Elem (a :: k) (as :: [k])
[Here] :: Elem a (a : as)
[There] :: Elem a as -> Elem a (b : as)

-- | Construct an <a>Elem</a> via Nat.
--   
--   This class could instead be a more direct version of
--   <tt>indexHList</tt>, but perhaps the <a>Elem</a> encoding will be
--   useful.
class IndexLabel name as ~ a => ElemOf name a as | as name -> a

-- | Construct the <a>Elem</a> corresponding to a Nat index.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; natElem @_ @0
--   Here
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; natElem @_ @3
--   There (There (There Here))
--   </pre>
elemOf :: ElemOf name a as => Elem '(name, a) as
instance forall (name :: GHC.Types.Symbol) a (as :: [(GHC.Types.Symbol, Type)]). ((Plutarch.DataRepr.Internal.HList.Utils.IndexLabel name as :: Type) GHC.Types.~ (a :: Type), Plutarch.DataRepr.Internal.HList.ElemOf name a as) => GHC.Records.HasField @{GHC.Types.Symbol} name (Plutarch.DataRepr.Internal.HList.HRecGeneric as) a
instance forall (name :: GHC.Types.Symbol) a (as :: [(GHC.Types.Symbol, Type)]). Plutarch.DataRepr.Internal.HList.ElemOf name a ((':) @(GHC.Types.Symbol, Type) '(name, a) as)
instance forall (name :: GHC.Types.Symbol) (b :: (GHC.Types.Symbol, Type)) (as :: [(GHC.Types.Symbol, Type)]) a. ((Plutarch.DataRepr.Internal.HList.Utils.IndexLabel name ((':) @(GHC.Types.Symbol, Type) b as) :: Type) GHC.Types.~ (a :: Type), Plutarch.DataRepr.Internal.HList.ElemOf name a as) => Plutarch.DataRepr.Internal.HList.ElemOf name a ((':) @(GHC.Types.Symbol, Type) b as)
instance forall (name :: GHC.Types.Symbol) a (as :: [(GHC.Types.Symbol, Type)]) (b :: Plutarch.Internal.PType) (c :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). ((Plutarch.DataRepr.Internal.HList.Utils.IndexLabel name as :: Type) GHC.Types.~ (a :: Type), Plutarch.DataRepr.Internal.HList.ElemOf name a as, (Plutarch.Internal.Term s (Plutarch.Builtin.PAsData b) :: Type) GHC.Types.~ (a :: Type), Plutarch.DataRepr.Internal.FromData.PFromDataable b c) => GHC.Records.HasField @{GHC.Types.Symbol} name (Plutarch.DataRepr.Internal.HList.HRec as) (Plutarch.Internal.Term s c)

module Plutarch.DataRepr.Internal

-- | A sum of <a>PDataRecord</a>s. The underlying representation is the
--   <tt>Constr</tt> constructor, where the integer is the index of the
--   variant and the list is the record.
newtype PDataSum defs s
PDataSum :: NS (Compose (Term s) PDataRecord) defs -> PDataSum defs s

-- | If there is only a single variant, then we can safely extract it.
punDataSum :: Term s (PDataSum '[def] :--> PDataRecord def)

-- | Try getting the nth variant. Errs if it's another variant.
ptryIndexDataSum :: KnownNat n => Proxy n -> Term s (PDataSum (def : defs) :--> PDataRecord (IndexList n (def : defs)))

-- | Cons a field to a data record.
--   
--   You can specify the label to associate with the field using type
--   applications-
--   
--   <pre>
--   foo :: Term s (PDataRecord '[ "fooField" ':= PByteString ])
--   foo = pdcons @"fooField" # pdata (phexByteStr "ab") # pdnil
--   </pre>
pdcons :: forall label a l s. Term s (PAsData a :--> (PDataRecord l :--> PDataRecord ((label := a) : l)))

-- | An empty <a>PDataRecord</a>.
pdnil :: Term s (PDataRecord '[])
data DataReprHandlers (out :: PType) (defs :: [[PLabeledType]]) (s :: S)
[DRHNil] :: DataReprHandlers out '[] s
[DRHCons] :: (Term s (PDataRecord def) -> Term s out) -> DataReprHandlers out defs s -> DataReprHandlers out (def : defs) s

-- | Type synonym to simplify deriving of <tt>PConstant</tt> via
--   <tt>DerivePConstantViaData</tt>.
--   
--   A type <tt>Foo a</tt> is considered <a>ConstantableData</a> if:
--   
--   <ul>
--   <li>The wrapped type <tt>a</tt> has a <tt>PConstant</tt>
--   instance.</li>
--   <li>The lifted type of <tt>a</tt> has a <tt>PUnsafeLiftDecl</tt>
--   instance.</li>
--   <li>There is type equality between <tt>a</tt> and <tt>PLifted
--   (PConstanted a)</tt>.</li>
--   <li>The newtype has <tt>FromData</tt> and <tt>ToData</tt>
--   instances</li>
--   </ul>
--   
--   These constraints are sufficient to derive a <tt>PConstant</tt>
--   instance for the newtype.
--   
--   For deriving <tt>PConstant</tt> for a wrapped type represented in UPLC
--   as <tt>Data</tt>, see <tt>DerivePConstantViaData</tt>.
--   
--   Polymorphic types can be derived as follows:
--   
--   <pre>
--   data Bar a = Bar a deriving stock (GHC.Generic)
--   
--   PlutusTx.makeLift ''Bar
--   PlutusTx.makeIsDataIndexed ''Bar [('Bar, 0)]
--   
--   data PBar (a :: PType) (s :: S)
--     = PBar (Term s (PDataRecord '["_0" ':= a]))
--     deriving stock (GHC.Generic)
--     deriving anyclass (SOP.Generic, PIsDataRepr)
--     deriving (PlutusType, PIsData, PDataFields) via PIsDataReprInstances (PBar a)
--   
--   instance
--     forall a.
--     PLiftData a =&gt;
--     PUnsafeLiftDecl (PBar a)
--     where
--     type PLifted (PBar a) = Bar (PLifted a)
--   
--   deriving via
--     ( DerivePConstantViaData
--         (Bar a)
--         (PBar (PConstanted a))
--     )
--     instance
--       PConstantData a =&gt;
--       PConstantDecl (Bar a)
--   </pre>
type PConstantData h = (PConstant h, FromData h, ToData h, PIsData (PConstanted h))

-- | A "record" of `exists a. PAsData a`. The underlying representation is
--   `PBuiltinList PData`.
data PDataRecord (as :: [PLabeledType]) (s :: S)
[PDCons] :: forall name_x x xs s. PUnLabel name_x ~ x => Term s (PAsData x) -> Term s (PDataRecord xs) -> PDataRecord (name_x : xs) s
[PDNil] :: PDataRecord '[] s
type PLiftData p = (PLift p, FromData (PLifted p), ToData (PLifted p), PIsData p)
data PLabeledType
(:=) :: Symbol -> PType -> PLabeledType
type family PLabelIndex (name :: Symbol) (as :: [PLabeledType]) :: Nat
type family PUnLabel (a :: PLabeledType) :: PType
type family PLookupLabel name as

-- | Safely index a <a>PDataRecord</a>.
pindexDataRecord :: KnownNat n => Proxy n -> Term s (PDataRecord as) -> Term s (PAsData (PUnLabel (IndexList n as)))

-- | Safely drop the first n items of a <a>PDataRecord</a>.
pdropDataRecord :: KnownNat n => Proxy n -> Term s (PDataRecord xs) -> Term s (PDataRecord (Drop n xs))

-- | For deriving <tt>PConstant</tt> for a wrapped type represented by a
--   builtin type, see <tt>DerivePConstantViaNewtype</tt>.
newtype DerivePConstantViaData (h :: Type) (p :: PType)

-- | The Haskell type for which @PConstant is being derived.
DerivePConstantViaData :: h -> DerivePConstantViaData (h :: Type) (p :: PType)
newtype DualReprHandler s out def
DualRepr :: (Term s (PDataRecord def) -> Term s (PDataRecord def) -> Term s out) -> DualReprHandler s out def
data PlutusTypeData
instance forall (as :: [(GHC.Types.Symbol, Plutarch.Internal.PType)]) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.DataRepr.Internal.HRecP as s)
instance forall k1 k2 (f :: k2 -> k1 -> Type) (a :: k1) (b :: k2). GHC.Generics.Generic (Plutarch.DataRepr.Internal.Flip @{k2} @{k1} f a b)
instance forall (b :: GHC.Types.Bool) (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.DataRepr.Internal.ExcessForField b a s)
instance forall k (a :: k -> Type) (b :: k -> Type) (s :: k). GHC.Generics.Generic (Plutarch.DataRepr.Internal.Helper @{k} a b s)
instance forall (n :: GHC.TypeNats.Nat) (x :: [Plutarch.DataRepr.Internal.PLabeledType]) (xs :: [[Plutarch.DataRepr.Internal.PLabeledType]]). (Plutarch.TryFrom.PTryFrom (Plutarch.Builtin.PBuiltinList Plutarch.Builtin.PData) (Plutarch.DataRepr.Internal.PDataRecord x), Plutarch.DataRepr.Internal.SumValidation (n GHC.TypeNats.+ 1) xs, GHC.TypeNats.KnownNat n) => Plutarch.DataRepr.Internal.SumValidation n ((':) @[Plutarch.DataRepr.Internal.PLabeledType] x xs)
instance forall (n :: GHC.TypeNats.Nat). Plutarch.DataRepr.Internal.SumValidation n ('[] @[Plutarch.DataRepr.Internal.PLabeledType])
instance forall (ys :: [[Plutarch.DataRepr.Internal.PLabeledType]]). Plutarch.DataRepr.Internal.SumValidation 0 ys => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.DataRepr.Internal.PDataSum ys)
instance forall (as :: [Plutarch.DataRepr.Internal.PLabeledType]) (ase :: [(GHC.Types.Symbol, Plutarch.Internal.PType)]). (Plutarch.TryFrom.PTryFrom (Plutarch.Builtin.PBuiltinList Plutarch.Builtin.PData) (Plutarch.DataRepr.Internal.PDataRecord as), (Plutarch.TryFrom.PTryFromExcess (Plutarch.Builtin.PBuiltinList Plutarch.Builtin.PData) (Plutarch.DataRepr.Internal.PDataRecord as) :: Plutarch.Internal.PType) GHC.Types.~ (Plutarch.DataRepr.Internal.HRecP ase :: Plutarch.Internal.PType)) => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.DataRepr.Internal.PDataRecord as))
instance forall (pty :: Plutarch.Internal.PType) (as :: [Plutarch.DataRepr.Internal.PLabeledType]) (ase :: [(GHC.Types.Symbol, Plutarch.Internal.PType)]) (name :: GHC.Types.Symbol). (Plutarch.DataRepr.Internal.Helper2 (Plutarch.TryFrom.PSubtype' Plutarch.Builtin.PData pty) pty, Plutarch.TryFrom.PTryFrom (Plutarch.Builtin.PBuiltinList Plutarch.Builtin.PData) (Plutarch.DataRepr.Internal.PDataRecord as), (Plutarch.TryFrom.PTryFromExcess (Plutarch.Builtin.PBuiltinList Plutarch.Builtin.PData) (Plutarch.DataRepr.Internal.PDataRecord as) :: Plutarch.Internal.PType) GHC.Types.~ (Plutarch.DataRepr.Internal.HRecP ase :: Plutarch.Internal.PType)) => Plutarch.TryFrom.PTryFrom (Plutarch.Builtin.PBuiltinList Plutarch.Builtin.PData) (Plutarch.DataRepr.Internal.PDataRecord ((':) @Plutarch.DataRepr.Internal.PLabeledType (name 'Plutarch.DataRepr.Internal.:= pty) as))
instance forall (a :: Plutarch.Internal.PType). Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData a) => Plutarch.DataRepr.Internal.Helper2 'GHC.Types.False a
instance forall (a :: Plutarch.Internal.PType). Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData a => Plutarch.DataRepr.Internal.Helper2 'GHC.Types.True a
instance Plutarch.TryFrom.PTryFrom (Plutarch.Builtin.PBuiltinList Plutarch.Builtin.PData) (Plutarch.DataRepr.Internal.PDataRecord ('[] @Plutarch.DataRepr.Internal.PLabeledType))
instance forall (p :: Plutarch.Internal.PType) h. (Plutarch.TryFrom.PSubtype Plutarch.Builtin.PData p, Plutarch.Lift.PLift p, PlutusTx.IsData.Class.FromData h, PlutusTx.IsData.Class.ToData h) => Plutarch.Lift.PConstantDecl (Plutarch.DataRepr.Internal.DerivePConstantViaData h p)
instance forall (a :: Plutarch.Internal.PType). (Plutarch.DataRepr.Internal.IsPDataSum (Plutarch.Internal.Generic.PCode a), Data.SOP.Constraint.SListI @{[Plutarch.DataRepr.Internal.PLabeledType]} (Plutarch.DataRepr.Internal.IsPDataSumDefs (Plutarch.Internal.Generic.PCode a)), Plutarch.Internal.Generic.PGeneric a) => Plutarch.DataRepr.Internal.PlutusTypeDataConstraint a
instance Plutarch.Internal.PlutusType.PlutusTypeStrat Plutarch.DataRepr.Internal.PlutusTypeData
instance forall (defs :: [[Plutarch.DataRepr.Internal.PLabeledType]]). Data.SOP.Constraint.SListI @{[Plutarch.DataRepr.Internal.PLabeledType]} defs => Plutarch.Internal.PlutusType.PlutusType (Plutarch.DataRepr.Internal.PDataSum defs)
instance Plutarch.DataRepr.Internal.IsPDataSum ('[] @[Plutarch.Internal.PType])
instance forall (xs :: [[Plutarch.Internal.PType]]) (l :: [Plutarch.DataRepr.Internal.PLabeledType]). Plutarch.DataRepr.Internal.IsPDataSum xs => Plutarch.DataRepr.Internal.IsPDataSum ((':) @[Plutarch.Internal.S -> Type] ((':) @(Plutarch.Internal.S -> Type) (Plutarch.DataRepr.Internal.PDataRecord l) ('[] @(Plutarch.Internal.S -> Type))) xs)
instance forall (defs :: [[Plutarch.DataRepr.Internal.PLabeledType]]). Plutarch.Builtin.PIsData (Plutarch.DataRepr.Internal.PDataSum defs)
instance forall (defs :: [[Plutarch.DataRepr.Internal.PLabeledType]]). Plutarch.Bool.PEq (Plutarch.DataRepr.Internal.PDataSum defs)
instance forall (defs :: [[Plutarch.DataRepr.Internal.PLabeledType]]). Data.SOP.Constraint.All @[Plutarch.DataRepr.Internal.PLabeledType] (Data.SOP.Constraint.Compose @{Plutarch.Internal.PType} @{[Plutarch.DataRepr.Internal.PLabeledType]} Plutarch.Bool.POrd Plutarch.DataRepr.Internal.PDataRecord) defs => Plutarch.Bool.POrd (Plutarch.DataRepr.Internal.PDataSum defs)
instance forall (ys :: [[Plutarch.DataRepr.Internal.PLabeledType]]). Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.DataRepr.Internal.PDataSum ys) => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.DataRepr.Internal.PDataSum ys))
instance forall (l :: [Plutarch.DataRepr.Internal.PLabeledType]). Data.SOP.Constraint.SListI @{Plutarch.DataRepr.Internal.PLabeledType} l => Plutarch.Internal.PlutusType.PlutusType (Plutarch.DataRepr.Internal.PDataRecord l)
instance forall (xs :: [Plutarch.DataRepr.Internal.PLabeledType]). Plutarch.Bool.PEq (Plutarch.DataRepr.Internal.PDataRecord xs)
instance Plutarch.Bool.POrd (Plutarch.DataRepr.Internal.PDataRecord ('[] @Plutarch.DataRepr.Internal.PLabeledType))
instance forall (x :: Plutarch.Internal.PType) (label :: GHC.Types.Symbol). (Plutarch.Bool.POrd x, Plutarch.Builtin.PIsData x) => Plutarch.Bool.POrd (Plutarch.DataRepr.Internal.PDataRecord ((':) @Plutarch.DataRepr.Internal.PLabeledType (label 'Plutarch.DataRepr.Internal.:= x) ('[] @Plutarch.DataRepr.Internal.PLabeledType)))
instance forall (xs :: [Plutarch.DataRepr.Internal.PLabeledType]) (x :: Plutarch.Internal.PType) (x' :: Plutarch.DataRepr.Internal.PLabeledType) (label :: GHC.Types.Symbol). (Data.SOP.Constraint.SListI @{Plutarch.DataRepr.Internal.PLabeledType} xs, Plutarch.Bool.POrd x, Plutarch.Builtin.PIsData x, Plutarch.Bool.POrd (Plutarch.DataRepr.Internal.PDataRecord ((':) @Plutarch.DataRepr.Internal.PLabeledType x' xs))) => Plutarch.Bool.POrd (Plutarch.DataRepr.Internal.PDataRecord ((':) @Plutarch.DataRepr.Internal.PLabeledType (label 'Plutarch.DataRepr.Internal.:= x) ((':) @Plutarch.DataRepr.Internal.PLabeledType x' xs)))
instance forall (xs :: [Plutarch.DataRepr.Internal.PLabeledType]). Plutarch.Builtin.PIsData (Plutarch.DataRepr.Internal.PDataRecord xs)

module Plutarch.DataRepr.Internal.Field

-- | Class allowing <tt>letFields</tt> to work for a PType, usually via
--   <tt>PIsDataRepr</tt>, but is derived for some other types for
--   convenience.
class PDataFields (a :: PType) where {
    
    -- | Fields in HRec bound by <tt>letFields</tt>
    type PFields a :: [PLabeledType];
    type PFields a = Helper (PInner a);
}

-- | Convert a Term to a <tt>PDataList</tt>
ptoFields :: PDataFields a => Term s a -> Term s (PDataRecord (PFields a))

-- | Convert a Term to a <tt>PDataList</tt>
ptoFields :: (PDataFields a, PInner a ~ PDataSum '[PFields a]) => Term s a -> Term s (PDataRecord (PFields a))

-- | Bind a HRec of named fields containing all the specified fields.
pletFields :: forall fs a s b ps bs. (PDataFields a, ps ~ PFields a, bs ~ Bindings ps fs, BindFields ps bs) => Term s a -> (HRecOf a fs s -> Term s b) -> Term s b

-- | Get a single field from a Term.
--   
--   <ul>
--   <li>NB*: If you access more than one field from the same value you
--   should use <a>pletFields</a> instead, which will generate the bindings
--   more efficiently.</li>
--   </ul>
pfield :: forall name p s a as n b. (PDataFields p, as ~ PFields p, n ~ PLabelIndex name as, KnownNat n, a ~ PUnLabel (IndexList n as), PFromDataable a b) => Term s (p :--> b)
class BindFields (ps :: [PLabeledType]) (bs :: [ToBind])

-- | Bind all the fields in a <tt>PDataList</tt> term to a corresponding
--   HList of Terms.
--   
--   A continuation is returned to enable sharing of the generated
--   bound-variables.
bindFields :: BindFields ps bs => Proxy bs -> Term s (PDataRecord ps) -> TermCont s (HRec (BoundTerms ps bs s))

-- | Map <a>BindField</a> over <tt>[PLabeledType]</tt>, with <tt>Skips</tt>
--   removed at tail
type family Bindings (ps :: [PLabeledType]) (fs :: [Symbol]) :: [ToBind]

-- | Get the <a>Term</a> representations to be bound based on the result of
--   <a>Bindings</a>.
type family BoundTerms ps bs s

-- | Drop first n fields of a list
type family Drop (n :: Nat) (as :: [k]) :: [k]

-- | The <a>HRec</a> yielded by 'pletFields @fs t'.
type HRecOf t fs s = HRec (BoundTerms (PFields t) (Bindings (PFields t) fs) s)

-- | Constrain an <a>HRec</a> to contain the specified fields from the
--   given Plutarch type.
--   
--   <h3>Example ===</h3>
--   
--   <pre>
--   import qualified GHC.Generics as GHC
--   import Generics.SOP
--   
--   import Plutarch.Prelude
--   import Plutarch.DataRepr
--   
--   newtype PFooType s = PFooType (Term s (PDataRecord '["frst" ':= PInteger, "scnd" ':= PBool, "thrd" ':= PString]))
--     deriving stock (GHC.Generic)
--     deriving anyclass (Generic)
--     deriving anyclass (PIsDataRepr)
--     deriving
--       (PlutusType, PIsData, PDataFields, PEq)
--       via PIsDataReprInstances PFooType
--   
--   foo :: PMemberFields PFooType '["scnd", "frst"] s as =&gt; HRec as -&gt; Term s PInteger
--   foo h = pif (getField <tt>"scnd" h) (getField </tt>"frst" h) 0
--   </pre>
type family PMemberFields t fs s as

-- | Single field version of <a>PMemberFields</a>.
type family PMemberField t name s as
data HRec as
[HNil] :: HRec '[]
[HCons] :: Labeled name a -> HRec as -> HRec ('(name, a) : as)
newtype Labeled sym a
Labeled :: a -> Labeled sym a
[unLabeled] :: Labeled sym a -> a

-- | Index a <a>HRec</a> with a field in a provided list of data fields.
--   Implicitly unwraps `PAsData a` to <tt>a</tt> when necessary.
--   
--   <pre>
--   &gt;&gt;&gt; xs = HRec @["x", "y", "z"] (HCons 1 (HCons 2 (HCons 3 HNil)))
--   
--   &gt;&gt;&gt; hrecField @"y" @["x", "y", "z"] xs
--   
--   &gt;&gt;&gt; 2
--   </pre>
hrecField :: forall name a as b c s. (ElemOf name a as, Term s (PAsData b) ~ a, PFromDataable b c) => HRec as -> Term s c
instance forall (l :: GHC.Types.Symbol) (p :: Plutarch.Internal.PType) (ps :: [Plutarch.DataRepr.Internal.PLabeledType]). Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType (l 'Plutarch.DataRepr.Internal.:= p) ps) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Bind ('[] @Plutarch.DataRepr.Internal.Field.ToBind))
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (l :: GHC.Types.Symbol) (p :: Plutarch.Internal.PType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType (l 'Plutarch.DataRepr.Internal.:= p) ps) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Bind bs)
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (p1 :: Plutarch.DataRepr.Internal.PLabeledType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType p1 ps) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip bs)
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (p1 :: Plutarch.DataRepr.Internal.PLabeledType) (p2 :: Plutarch.DataRepr.Internal.PLabeledType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType p1 ((':) @Plutarch.DataRepr.Internal.PLabeledType p2 ps)) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip bs))
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (p1 :: Plutarch.DataRepr.Internal.PLabeledType) (p2 :: Plutarch.DataRepr.Internal.PLabeledType) (p3 :: Plutarch.DataRepr.Internal.PLabeledType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType p1 ((':) @Plutarch.DataRepr.Internal.PLabeledType p2 ((':) @Plutarch.DataRepr.Internal.PLabeledType p3 ps))) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip bs)))
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (p1 :: Plutarch.DataRepr.Internal.PLabeledType) (p2 :: Plutarch.DataRepr.Internal.PLabeledType) (p3 :: Plutarch.DataRepr.Internal.PLabeledType) (p4 :: Plutarch.DataRepr.Internal.PLabeledType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType p1 ((':) @Plutarch.DataRepr.Internal.PLabeledType p2 ((':) @Plutarch.DataRepr.Internal.PLabeledType p3 ((':) @Plutarch.DataRepr.Internal.PLabeledType p4 ps)))) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip bs))))
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (p1 :: Plutarch.DataRepr.Internal.PLabeledType) (p2 :: Plutarch.DataRepr.Internal.PLabeledType) (p3 :: Plutarch.DataRepr.Internal.PLabeledType) (p4 :: Plutarch.DataRepr.Internal.PLabeledType) (p5 :: Plutarch.DataRepr.Internal.PLabeledType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType p1 ((':) @Plutarch.DataRepr.Internal.PLabeledType p2 ((':) @Plutarch.DataRepr.Internal.PLabeledType p3 ((':) @Plutarch.DataRepr.Internal.PLabeledType p4 ((':) @Plutarch.DataRepr.Internal.PLabeledType p5 ps))))) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip bs)))))
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (p1 :: Plutarch.DataRepr.Internal.PLabeledType) (p2 :: Plutarch.DataRepr.Internal.PLabeledType) (p3 :: Plutarch.DataRepr.Internal.PLabeledType) (p4 :: Plutarch.DataRepr.Internal.PLabeledType) (p5 :: Plutarch.DataRepr.Internal.PLabeledType) (p6 :: Plutarch.DataRepr.Internal.PLabeledType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType p1 ((':) @Plutarch.DataRepr.Internal.PLabeledType p2 ((':) @Plutarch.DataRepr.Internal.PLabeledType p3 ((':) @Plutarch.DataRepr.Internal.PLabeledType p4 ((':) @Plutarch.DataRepr.Internal.PLabeledType p5 ((':) @Plutarch.DataRepr.Internal.PLabeledType p6 ps)))))) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip bs))))))
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (p1 :: Plutarch.DataRepr.Internal.PLabeledType) (p2 :: Plutarch.DataRepr.Internal.PLabeledType) (p3 :: Plutarch.DataRepr.Internal.PLabeledType) (p4 :: Plutarch.DataRepr.Internal.PLabeledType) (p5 :: Plutarch.DataRepr.Internal.PLabeledType) (p6 :: Plutarch.DataRepr.Internal.PLabeledType) (p7 :: Plutarch.DataRepr.Internal.PLabeledType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType p1 ((':) @Plutarch.DataRepr.Internal.PLabeledType p2 ((':) @Plutarch.DataRepr.Internal.PLabeledType p3 ((':) @Plutarch.DataRepr.Internal.PLabeledType p4 ((':) @Plutarch.DataRepr.Internal.PLabeledType p5 ((':) @Plutarch.DataRepr.Internal.PLabeledType p6 ((':) @Plutarch.DataRepr.Internal.PLabeledType p7 ps))))))) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip bs)))))))
instance forall (as :: [Plutarch.DataRepr.Internal.PLabeledType]). Plutarch.DataRepr.Internal.Field.PDataFields (Plutarch.DataRepr.Internal.PDataRecord as)
instance forall (as :: [Plutarch.DataRepr.Internal.PLabeledType]). Plutarch.DataRepr.Internal.Field.PDataFields (Plutarch.DataRepr.Internal.PDataSum ((':) @[Plutarch.DataRepr.Internal.PLabeledType] as ('[] @[Plutarch.DataRepr.Internal.PLabeledType])))
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Builtin.PIsData a, Plutarch.DataRepr.Internal.Field.PDataFields a) => Plutarch.DataRepr.Internal.Field.PDataFields (Plutarch.Builtin.PAsData a)

module Plutarch.DataRepr

-- | A sum of <a>PDataRecord</a>s. The underlying representation is the
--   <tt>Constr</tt> constructor, where the integer is the index of the
--   variant and the list is the record.
newtype PDataSum defs s
PDataSum :: NS (Compose (Term s) PDataRecord) defs -> PDataSum defs s

-- | If there is only a single variant, then we can safely extract it.
punDataSum :: Term s (PDataSum '[def] :--> PDataRecord def)

-- | Try getting the nth variant. Errs if it's another variant.
ptryIndexDataSum :: KnownNat n => Proxy n -> Term s (PDataSum (def : defs) :--> PDataRecord (IndexList n (def : defs)))
data DataReprHandlers (out :: PType) (defs :: [[PLabeledType]]) (s :: S)
[DRHNil] :: DataReprHandlers out '[] s
[DRHCons] :: (Term s (PDataRecord def) -> Term s out) -> DataReprHandlers out defs s -> DataReprHandlers out (def : defs) s

-- | A "record" of `exists a. PAsData a`. The underlying representation is
--   `PBuiltinList PData`.
data PDataRecord (as :: [PLabeledType]) (s :: S)
[PDCons] :: forall name_x x xs s. PUnLabel name_x ~ x => Term s (PAsData x) -> Term s (PDataRecord xs) -> PDataRecord (name_x : xs) s
[PDNil] :: PDataRecord '[] s

-- | Cons a field to a data record.
--   
--   You can specify the label to associate with the field using type
--   applications-
--   
--   <pre>
--   foo :: Term s (PDataRecord '[ "fooField" ':= PByteString ])
--   foo = pdcons @"fooField" # pdata (phexByteStr "ab") # pdnil
--   </pre>
pdcons :: forall label a l s. Term s (PAsData a :--> (PDataRecord l :--> PDataRecord ((label := a) : l)))

-- | An empty <a>PDataRecord</a>.
pdnil :: Term s (PDataRecord '[])
data PLabeledType
(:=) :: Symbol -> PType -> PLabeledType

-- | Safely index a <a>PDataRecord</a>.
pindexDataRecord :: KnownNat n => Proxy n -> Term s (PDataRecord as) -> Term s (PAsData (PUnLabel (IndexList n as)))

-- | Safely drop the first n items of a <a>PDataRecord</a>.
pdropDataRecord :: KnownNat n => Proxy n -> Term s (PDataRecord xs) -> Term s (PDataRecord (Drop n xs))

-- | For deriving <tt>PConstant</tt> for a wrapped type represented by a
--   builtin type, see <tt>DerivePConstantViaNewtype</tt>.
newtype DerivePConstantViaData (h :: Type) (p :: PType)

-- | The Haskell type for which @PConstant is being derived.
DerivePConstantViaData :: h -> DerivePConstantViaData (h :: Type) (p :: PType)

-- | Type synonym to simplify deriving of <tt>PConstant</tt> via
--   <tt>DerivePConstantViaData</tt>.
--   
--   A type <tt>Foo a</tt> is considered <a>ConstantableData</a> if:
--   
--   <ul>
--   <li>The wrapped type <tt>a</tt> has a <tt>PConstant</tt>
--   instance.</li>
--   <li>The lifted type of <tt>a</tt> has a <tt>PUnsafeLiftDecl</tt>
--   instance.</li>
--   <li>There is type equality between <tt>a</tt> and <tt>PLifted
--   (PConstanted a)</tt>.</li>
--   <li>The newtype has <tt>FromData</tt> and <tt>ToData</tt>
--   instances</li>
--   </ul>
--   
--   These constraints are sufficient to derive a <tt>PConstant</tt>
--   instance for the newtype.
--   
--   For deriving <tt>PConstant</tt> for a wrapped type represented in UPLC
--   as <tt>Data</tt>, see <tt>DerivePConstantViaData</tt>.
--   
--   Polymorphic types can be derived as follows:
--   
--   <pre>
--   data Bar a = Bar a deriving stock (GHC.Generic)
--   
--   PlutusTx.makeLift ''Bar
--   PlutusTx.makeIsDataIndexed ''Bar [('Bar, 0)]
--   
--   data PBar (a :: PType) (s :: S)
--     = PBar (Term s (PDataRecord '["_0" ':= a]))
--     deriving stock (GHC.Generic)
--     deriving anyclass (SOP.Generic, PIsDataRepr)
--     deriving (PlutusType, PIsData, PDataFields) via PIsDataReprInstances (PBar a)
--   
--   instance
--     forall a.
--     PLiftData a =&gt;
--     PUnsafeLiftDecl (PBar a)
--     where
--     type PLifted (PBar a) = Bar (PLifted a)
--   
--   deriving via
--     ( DerivePConstantViaData
--         (Bar a)
--         (PBar (PConstanted a))
--     )
--     instance
--       PConstantData a =&gt;
--       PConstantDecl (Bar a)
--   </pre>
type PConstantData h = (PConstant h, FromData h, ToData h, PIsData (PConstanted h))
type PLiftData p = (PLift p, FromData (PLifted p), ToData (PLifted p), PIsData p)
data PlutusTypeData

-- | Class allowing <tt>letFields</tt> to work for a PType, usually via
--   <tt>PIsDataRepr</tt>, but is derived for some other types for
--   convenience.
class PDataFields (a :: PType) where {
    
    -- | Fields in HRec bound by <tt>letFields</tt>
    type PFields a :: [PLabeledType];
    type PFields a = Helper (PInner a);
}

-- | Convert a Term to a <tt>PDataList</tt>
ptoFields :: PDataFields a => Term s a -> Term s (PDataRecord (PFields a))

-- | Convert a Term to a <tt>PDataList</tt>
ptoFields :: (PDataFields a, PInner a ~ PDataSum '[PFields a]) => Term s a -> Term s (PDataRecord (PFields a))

-- | Bind a HRec of named fields containing all the specified fields.
pletFields :: forall fs a s b ps bs. (PDataFields a, ps ~ PFields a, bs ~ Bindings ps fs, BindFields ps bs) => Term s a -> (HRecOf a fs s -> Term s b) -> Term s b

-- | Get a single field from a Term.
--   
--   <ul>
--   <li>NB*: If you access more than one field from the same value you
--   should use <a>pletFields</a> instead, which will generate the bindings
--   more efficiently.</li>
--   </ul>
pfield :: forall name p s a as n b. (PDataFields p, as ~ PFields p, n ~ PLabelIndex name as, KnownNat n, a ~ PUnLabel (IndexList n as), PFromDataable a b) => Term s (p :--> b)
data HRec as

-- | The <a>HRec</a> yielded by 'pletFields @fs t'.
type HRecOf t fs s = HRec (BoundTerms (PFields t) (Bindings (PFields t) fs) s)

-- | Constrain an <a>HRec</a> to contain the specified fields from the
--   given Plutarch type.
--   
--   <h3>Example ===</h3>
--   
--   <pre>
--   import qualified GHC.Generics as GHC
--   import Generics.SOP
--   
--   import Plutarch.Prelude
--   import Plutarch.DataRepr
--   
--   newtype PFooType s = PFooType (Term s (PDataRecord '["frst" ':= PInteger, "scnd" ':= PBool, "thrd" ':= PString]))
--     deriving stock (GHC.Generic)
--     deriving anyclass (Generic)
--     deriving anyclass (PIsDataRepr)
--     deriving
--       (PlutusType, PIsData, PDataFields, PEq)
--       via PIsDataReprInstances PFooType
--   
--   foo :: PMemberFields PFooType '["scnd", "frst"] s as =&gt; HRec as -&gt; Term s PInteger
--   foo h = pif (getField <tt>"scnd" h) (getField </tt>"frst" h) 0
--   </pre>
type family PMemberFields t fs s as

-- | Single field version of <a>PMemberFields</a>.
type family PMemberField t name s as

module Plutarch.Prelude
data (:-->) (a :: PType) (b :: PType) (s :: S)
infixr 0 :-->
data PDelayed (a :: PType) (s :: S)
data Term (s :: S) (a :: PType)

-- | <ul>
--   <li>Closed* terms with no free variables.</li>
--   </ul>
type ClosedTerm (a :: PType) = forall (s :: S). Term s a
plam :: forall c. PLamN a b s => (Term s c -> a) -> Term s (c :--> b)

-- | Lambda Application.
papp :: HasCallStack => Term s (a :--> b) -> Term s a -> Term s b

-- | Plutus 'delay', used for laziness.
pdelay :: Term s a -> Term s (PDelayed a)

-- | Plutus 'force', used to force evaluation of <a>PDelayed</a> terms.
pforce :: Term s (PDelayed a) -> Term s a
phoistAcyclic :: HasCallStack => ClosedTerm a -> Term s a

-- | Plutus 'error'.
--   
--   When using this explicitly, it should be ensured that the containing
--   term is delayed, avoiding premature evaluation.
perror :: Term s a

-- | Low precedence infixr synonym of <a>papp</a>, to be used like
--   <a>$</a>, in combination with <a>#</a>. e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; f # x #$ g # y # z
--   f x (g y z)
--   </pre>
(#$) :: HasCallStack => Term s (a :--> b) -> Term s a -> Term s b
infixr 0 #$

-- | High precedence infixl synonym of <a>papp</a>, to be used like
--   function juxtaposition. e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; f # x # y
--   f x y
--   </pre>
(#) :: HasCallStack => Term s (a :--> b) -> Term s a -> Term s b
infixl 8 #

-- | Let bindings.
--   
--   This is appoximately a shorthand for a lambda and application:
--   
--   <tt>plet v f</tt> == <tt> papp (plam f) v</tt>
--   
--   But sufficiently small terms in WHNF may be inlined for efficiency.
plet :: Term s a -> (Term s a -> Term s b) -> Term s b
pinl :: Term s a -> (Term s a -> Term s b) -> Term s b

-- | Safely coerce from a Term to it's <a>PInner</a> representation.
pto :: Term s a -> Term s (PInner a)

-- | Fixpoint recursion. Used to encode recursive functions.
--   
--   Example:
--   
--   <pre>
--   iterateN' ::
--    Term s (PInteger :--&gt; (a :--&gt; a) :--&gt; a :--&gt; a) -&gt;
--    Term s PInteger -&gt;
--    Term s (a :--&gt; a) -&gt;
--    Term s a
--   iterateN' self n f x =
--     pif (n #== 0) x (self # n - 1 #$ f x)
--   
--   iterateN :: Term s (PInteger :--&gt; (a :--&gt; a) :--&gt; a :--&gt; a)
--   iterateN = pfix #$ plam iterateN'
--   </pre>
--   
--   Further examples can be found in examples/Recursion.hs
pfix :: Term s (((a :--> b) :--> (a :--> b)) :--> (a :--> b))

-- | The kind of types with lifted values. For example <tt>Int ::
--   Type</tt>.
type Type = TYPE LiftedRep
data S

-- | Shorthand for Plutarch types.
type PType = S -> Type
class PlutusType (a :: PType) where {
    type PInner a :: PType;
    type PInner a = DerivedPInner (DPTStrat a) a;
    type PCovariant' a = All2 PCovariant'' (PCode a);
    type PContravariant' a = All2 PContravariant'' (PCode a);
    type PVariant' a = All2 PVariant'' (PCode a);
}
class (PInner a ~ DerivedPInner (DPTStrat a) a, PlutusTypeStrat (DPTStrat a), PlutusTypeStratConstraint (DPTStrat a) a, PlutusType a) => DerivePlutusType (a :: PType)
type DPTStrat a :: Type
data PlutusTypeScott
data PlutusTypeNewtype
data PlutusTypeData

-- | <i>Deprecated: Use PlutusType</i>
type PCon = PlutusType

-- | <i>Deprecated: Use PlutusType</i>
type PMatch = PlutusType

-- | Construct a Plutarch Term via a Haskell datatype
pcon :: PlutusType a => a s -> Term s a

-- | Pattern match over Plutarch Terms via a Haskell datatype
pmatch :: PlutusType a => Term s a -> (a s -> Term s b) -> Term s b
newtype PForall (b :: a -> PType) s
PForall :: (forall (x :: a). Term s (b x)) -> PForall (b :: a -> PType) s

-- | Plutus BuiltinInteger
data PInteger s
class PIntegral a
pdiv :: PIntegral a => Term s (a :--> (a :--> a))
pdiv :: (PIntegral a, PIntegral (PInner a)) => Term s (a :--> (a :--> a))
pmod :: PIntegral a => Term s (a :--> (a :--> a))
pmod :: (PIntegral a, PIntegral (PInner a)) => Term s (a :--> (a :--> a))
pquot :: PIntegral a => Term s (a :--> (a :--> a))
pquot :: (PIntegral a, PIntegral (PInner a)) => Term s (a :--> (a :--> a))
prem :: PIntegral a => Term s (a :--> (a :--> a))
prem :: (PIntegral a, PIntegral (PInner a)) => Term s (a :--> (a :--> a))
data PRational s
pnumerator :: Term s (PRational :--> PInteger)
pdenominator :: Term s (PRational :--> PInteger)
pfromInteger :: Term s (PInteger :--> PRational)
pround :: Term s (PRational :--> PInteger)

-- | Plutus <tt>BuiltinBool</tt>
data PBool (s :: S)
PTrue :: PBool (s :: S)
PFalse :: PBool (s :: S)
class PEq t
(#==) :: PEq t => Term s t -> Term s t -> Term s PBool
(#==) :: (PEq t, PGeneric t, PlutusType t, All2 PEq (PCode t)) => Term s t -> Term s t -> Term s PBool
infix 4 #==
class PEq t => POrd t
(#<=) :: POrd t => Term s t -> Term s t -> Term s PBool
(#<=) :: (POrd t, POrd (PInner t)) => Term s t -> Term s t -> Term s PBool
(#<) :: POrd t => Term s t -> Term s t -> Term s PBool
(#<) :: (POrd t, POrd (PInner t)) => Term s t -> Term s t -> Term s PBool
infix 4 #<=
infix 4 #<

-- | Lazy if-then-else.
pif :: Term s PBool -> Term s a -> Term s a -> Term s a

-- | Boolean negation for <a>PBool</a> terms.
pnot :: Term s (PBool :--> PBool)

-- | Lazily evaluated boolean and for <a>PBool</a> terms.
(#&&) :: Term s PBool -> Term s PBool -> Term s PBool
infixr 3 #&&

-- | Lazily evaluated boolean or for <a>PBool</a> terms.
(#||) :: Term s PBool -> Term s PBool -> Term s PBool
infixr 2 #||

-- | Plutus <tt>BuiltinByteString</tt>
data PByteString s

-- | Interpret a hex string as a PByteString.
phexByteStr :: HasCallStack => String -> Term s PByteString

-- | Prepend a byte, represented by a non negative <a>PInteger</a>, to a
--   <tt>PBytestring</tt>.
pconsBS :: Term s (PInteger :--> (PByteString :--> PByteString))

-- | Slice a <a>PByteString</a> with given start index and slice length.
--   
--   <pre>
--   &gt;&gt;&gt; (pslice # 2 # 3 phexByteStr "4102afde5b2a") #== phexByteStr "afde5b"
--   </pre>
psliceBS :: Term s (PInteger :--> (PInteger :--> (PByteString :--> PByteString)))

-- | Find the length of a <a>PByteString</a>.
plengthBS :: Term s (PByteString :--> PInteger)

-- | <a>PByteString</a> indexing function.
pindexBS :: Term s (PByteString :--> (PInteger :--> PInteger))

-- | Plutus <tt>BuiltinString</tt> values
data PString s

-- | Encode a <a>PString</a> using UTF-8.
pencodeUtf8 :: Term s (PString :--> PByteString)

-- | Decode a <a>PByteString</a> using UTF-8.
pdecodeUtf8 :: Term s (PByteString :--> PString)
data PUnit s
PUnit :: PUnit s

-- | Plutarch types that behave like lists.
class PListLike (list :: (PType) -> PType) where {
    type PElemConstraint list (a :: PType) :: Constraint;
}

-- | Canonical eliminator for list-likes.
pelimList :: (PListLike list, PElemConstraint list a) => (Term s a -> Term s (list a) -> Term s r) -> Term s r -> Term s (list a) -> Term s r

-- | Cons an element onto an existing list.
pcons :: (PListLike list, PElemConstraint list a) => Term s (a :--> (list a :--> list a))

-- | The empty list
pnil :: (PListLike list, PElemConstraint list a) => Term s (list a)

-- | Return the first element of a list. Partial, throws an error upon
--   encountering an empty list.
phead :: (PListLike list, PElemConstraint list a) => Term s (list a :--> a)

-- | Take the tail of a list, meaning drop its head. Partial, throws an
--   error upon encountering an empty list.
ptail :: (PListLike list, PElemConstraint list a) => Term s (list a :--> list a)

-- | <i> O(1) </i>. Check if a list is empty
pnull :: (PListLike list, PElemConstraint list a) => Term s (list a :--> PBool)

-- | 'PIsListLike list a' constraints <tt>list</tt> be a <a>PListLike</a>
--   with valid element type, <tt>a</tt>.
type PIsListLike list a = (PListLike list, PElemConstraint list a)

-- | <i> O(min(n, m)) </i>. Check if two lists are equal.
plistEquals :: (PIsListLike list a, PEq a) => Term s (list a :--> (list a :--> PBool))

-- | <i> O(n) </i>. Check if element is in the list
pelem :: (PIsListLike list a, PEq a) => Term s (a :--> (list a :--> PBool))

-- | <i> O(n) </i>. Like Haskell level <a>(!!)</a> but on the Plutarch
--   level, not infix and with arguments reversed, errors if the specified
--   index is greater than or equal to the lists length
pelemAt :: PIsListLike l a => Term s (PInteger :--> (l a :--> a))

-- | <i> O(n) </i>. Count the number of elements in the list
plength :: PIsListLike list a => Term s (list a :--> PInteger)

-- | Index a BuiltinList, throwing an error if the index is out of bounds.
ptryIndex :: PIsListLike list a => Natural -> Term s (list a) -> Term s a

-- | Drop the first n fields of a List.
--   
--   The term will be statically generated as repeated applications of
--   <a>ptail</a>, which will be more efficient in many circumstances.
pdrop :: PIsListLike list a => Natural -> Term s (list a) -> Term s (list a)

-- | <i> O(1) </i>. Create a singleton list from an element
psingleton :: PIsListLike list a => Term s (a :--> list a)

-- | <i> O(n) </i>. Concatenate two lists
--   
--   Example: &gt; pconcat # psingleton x # psingleton y == plistLiteral
--   [x, y]
--   
--   pconcat exhibits identities with empty lists such that &gt; forall x.
--   pconcat # pnil # x == x &gt; forall x. pconcat # x # pnil == x
pconcat :: PIsListLike list a => Term s (list a :--> (list a :--> list a))

-- | <i> O(min(n, m)) </i>. Zip two lists together with a passed function.
--   
--   If the lists are of differing lengths, cut to the shortest.
pzipWith :: (PListLike list, PElemConstraint list a, PElemConstraint list b, PElemConstraint list c) => Term s ((a :--> (b :--> c)) :--> (list a :--> (list b :--> list c)))

-- | Like <a>pzipWith</a> but with Haskell-level merge function.
pzipWith' :: (PListLike list, PElemConstraint list a, PElemConstraint list b, PElemConstraint list c) => (Term s a -> Term s b -> Term s c) -> Term s (list a :--> (list b :--> list c))

-- | <i> O(min(n, m)) </i>. Zip two lists together, creating pairs of the
--   elements.
--   
--   If the lists are of differing lengths, cut to the shortest.
pzip :: (PListLike list, PElemConstraint list a, PElemConstraint list b, PElemConstraint list (PPair a b)) => Term s (list a :--> (list b :--> list (PPair a b)))

-- | <i> O(n) </i>. Map a function over a list of elements
pmap :: (PListLike list, PElemConstraint list a, PElemConstraint list b) => Term s ((a :--> b) :--> (list a :--> list b))

-- | <i> O(n) </i>. Filter elements from a list that don't match the
--   predicate.
pfilter :: PIsListLike list a => Term s ((a :--> PBool) :--> (list a :--> list a))

-- | <i> O(n) </i>. like haskell level <tt>find</tt> but on plutarch level
pfind :: PIsListLike l a => Term s ((a :--> PBool) :--> (l a :--> PMaybe a))

-- | Like <a>pelimList</a>, but with a fixpoint recursion hatch.
precList :: PIsListLike list a => (Term s (list a :--> r) -> Term s a -> Term s (list a) -> Term s r) -> (Term s (list a :--> r) -> Term s r) -> Term s (list a :--> r)

-- | <i> O(n) </i>. Fold on a list right-associatively.
pfoldr :: PIsListLike list a => Term s ((a :--> (b :--> b)) :--> (b :--> (list a :--> b)))

-- | <i> O(n) </i>. Fold on a list right-associatively, with opportunity
--   for short circuting.
--   
--   May short circuit when given reducer function is lazy in its second
--   argument.
pfoldrLazy :: PIsListLike list a => Term s ((a :--> (PDelayed b :--> b)) :--> (b :--> (list a :--> b)))

-- | <i> O(n) </i>. Fold on a list left-associatively.
pfoldl :: PIsListLike list a => Term s ((b :--> (a :--> b)) :--> (b :--> (list a :--> b)))

-- | <i> O(n) </i>. Check that predicate holds for all elements in a list.
pall :: PIsListLike list a => Term s ((a :--> PBool) :--> (list a :--> PBool))

-- | <i> O(n) </i>. Check that predicate holds for any element in a list.
pany :: PIsListLike list a => Term s ((a :--> PBool) :--> (list a :--> PBool))

-- | <i> O(n) </i>. Like Haskell level <a>(!!)</a> but on the plutarch
--   level
(#!!) :: PIsListLike l a => Term s (l a) -> Term s PInteger -> Term s a
data PList (a :: PType) (s :: S)
PSCons :: Term s a -> Term s (PList a) -> PList (a :: PType) (s :: S)
PSNil :: PList (a :: PType) (s :: S)

-- | Plutus Maybe type, with Scott-encoded repr
data PMaybe (a :: PType) (s :: S)
PJust :: Term s a -> PMaybe (a :: PType) (s :: S)
PNothing :: PMaybe (a :: PType) (s :: S)
data PEither (a :: PType) (b :: PType) (s :: S)
PLeft :: Term s a -> PEither (a :: PType) (b :: PType) (s :: S)
PRight :: Term s b -> PEither (a :: PType) (b :: PType) (s :: S)

-- | Plutus encoding of Pairs.
--   
--   Note: This is represented differently than <tt>BuiltinPair</tt>. It is
--   scott-encoded.
data PPair (a :: PType) (b :: PType) (s :: S)
PPair :: Term s a -> Term s b -> PPair (a :: PType) (b :: PType) (s :: S)

-- | An Arbitrary Term with an unknown type
data POpaque s
POpaque :: Term s POpaque -> POpaque s

-- | Erase the type of a Term
popaque :: Term s a -> Term s POpaque
data PData (s :: S)
pfstBuiltin :: Term s (PBuiltinPair a b :--> a)
psndBuiltin :: Term s (PBuiltinPair a b :--> b)

-- | Plutus <tt>BuiltinPair</tt>
data PBuiltinPair (a :: PType) (b :: PType) (s :: S)

-- | Plutus <tt>BuiltinList</tt>
data PBuiltinList (a :: PType) (s :: S)
PCons :: Term s a -> Term s (PBuiltinList a) -> PBuiltinList (a :: PType) (s :: S)
PNil :: PBuiltinList (a :: PType) (s :: S)

-- | Laws: - If <tt>PSubtype PData a</tt>, then <tt>pdataImpl a</tt> must
--   be <a>pupcast</a>. - pdataImpl . pupcast . pfromDataImpl ≡ id -
--   pfromDataImpl . punsafeDowncast . pdataImpl ≡ id
class PIsData a
pfromData :: PIsData a => Term s (PAsData a) -> Term s a
pdata :: PIsData a => Term s a -> Term s (PAsData a)
data PAsData (a :: PType) (s :: S)

-- | A "record" of `exists a. PAsData a`. The underlying representation is
--   `PBuiltinList PData`.
data PDataRecord (as :: [PLabeledType]) (s :: S)

-- | A sum of <a>PDataRecord</a>s. The underlying representation is the
--   <tt>Constr</tt> constructor, where the integer is the index of the
--   variant and the list is the record.
data PDataSum defs s
data PLabeledType
(:=) :: Symbol -> PType -> PLabeledType

-- | Cons a field to a data record.
--   
--   You can specify the label to associate with the field using type
--   applications-
--   
--   <pre>
--   foo :: Term s (PDataRecord '[ "fooField" ':= PByteString ])
--   foo = pdcons @"fooField" # pdata (phexByteStr "ab") # pdnil
--   </pre>
pdcons :: forall label a l s. Term s (PAsData a :--> (PDataRecord l :--> PDataRecord ((label := a) : l)))

-- | An empty <a>PDataRecord</a>.
pdnil :: Term s (PDataRecord '[])

-- | Get a single field from a Term.
--   
--   <ul>
--   <li>NB*: If you access more than one field from the same value you
--   should use <a>pletFields</a> instead, which will generate the bindings
--   more efficiently.</li>
--   </ul>
pfield :: forall name p s a as n b. (PDataFields p, as ~ PFields p, n ~ PLabelIndex name as, KnownNat n, a ~ PUnLabel (IndexList n as), PFromDataable a b) => Term s (p :--> b)

-- | Selector function to extract the field from the record.
getField :: HasField x r a => r -> a

-- | Bind a HRec of named fields containing all the specified fields.
pletFields :: forall fs a s b ps bs. (PDataFields a, ps ~ PFields a, bs ~ Bindings ps fs, BindFields ps bs) => Term s a -> (HRecOf a fs s -> Term s b) -> Term s b

-- | Trace the given message before evaluating the argument.
ptrace :: Term s PString -> Term s a -> Term s a

-- | Like Haskell's <tt>traceShowId</tt> but for Plutarch
ptraceShowId :: PShow a => Term s a -> Term s a

-- | Trace the given message if the argument evaluates to False.
ptraceIfFalse :: Term s PString -> Term s PBool -> Term s PBool

-- | Trace the given message if the argument evaluates to true.
ptraceIfTrue :: Term s PString -> Term s PBool -> Term s PBool

-- | Trace the given message and terminate evaluation with a <a>perror</a>.
ptraceError :: Term s PString -> Term s a

-- | Return the string representation of a Plutarch value
pshow :: PShow a => Term s a -> Term s PString

-- | Hash a <a>PByteString</a> using SHA-256.
psha2_256 :: Term s (PByteString :--> PByteString)

-- | Hash a <a>PByteString</a> using SHA3-256.
psha3_256 :: Term s (PByteString :--> PByteString)

-- | Verify the signature against the public key and message.
pverifySignature :: Term s (PByteString :--> (PByteString :--> (PByteString :--> PBool)))

-- | Create a Plutarch-level constant, from a Haskell value. Example: &gt;
--   pconstant @PInteger 42
pconstant :: forall p s. PLift p => PLifted p -> Term s p

-- | Create a Plutarch-level <a>PAsData</a> constant, from a Haskell value.
--   Example: &gt; pconstantData @PInteger 42
pconstantData :: forall p h s. (ToData h, PLifted p ~ h, PConstanted h ~ p) => h -> Term s (PAsData p)

-- | Like <a>plift</a>` but throws on failure.
plift :: forall p. (HasCallStack, PLift p) => ClosedTerm p -> PLifted p

-- | Type synonym to simplify deriving of <tt>PConstant</tt> via
--   <tt>DerivePConstantViaNewtype</tt>.
--   
--   A newtype <tt>Foo a</tt> is considered <a>Constantable</a> if:
--   
--   <ul>
--   <li>The wrapped type <tt>a</tt> has a <tt>PConstant</tt>
--   instance.</li>
--   <li>The lifted type of <tt>a</tt> has a <tt>PUnsafeLiftDecl</tt>
--   instance.</li>
--   <li>There is type equality between <tt>a</tt> and <tt>PLifted
--   (PConstanted a)</tt>.</li>
--   </ul>
--   
--   These constraints are sufficient to derive a <tt>PConstant</tt>
--   instance for the newtype.
--   
--   For deriving <tt>PConstant</tt> for a wrapped type represented in UPLC
--   as <tt>Data</tt>, see <tt>DerivePConstantViaData</tt>.
type PConstant a = (a ~ PLifted (PConstanted a), PConstantDecl a)

-- | Class of Plutarch types <tt>p</tt> that can be converted to/from a
--   Haskell type.
--   
--   The Haskell type is determined by `PLifted p`.
--   
--   This typeclass is closely tied with <a>PConstant</a>.
type PLift = PUnsafeLiftDecl

-- | Type synonym to simplify deriving of <tt>PConstant</tt> via
--   <tt>DerivePConstantViaData</tt>.
--   
--   A type <tt>Foo a</tt> is considered <a>ConstantableData</a> if:
--   
--   <ul>
--   <li>The wrapped type <tt>a</tt> has a <tt>PConstant</tt>
--   instance.</li>
--   <li>The lifted type of <tt>a</tt> has a <tt>PUnsafeLiftDecl</tt>
--   instance.</li>
--   <li>There is type equality between <tt>a</tt> and <tt>PLifted
--   (PConstanted a)</tt>.</li>
--   <li>The newtype has <tt>FromData</tt> and <tt>ToData</tt>
--   instances</li>
--   </ul>
--   
--   These constraints are sufficient to derive a <tt>PConstant</tt>
--   instance for the newtype.
--   
--   For deriving <tt>PConstant</tt> for a wrapped type represented in UPLC
--   as <tt>Data</tt>, see <tt>DerivePConstantViaData</tt>.
--   
--   Polymorphic types can be derived as follows:
--   
--   <pre>
--   data Bar a = Bar a deriving stock (GHC.Generic)
--   
--   PlutusTx.makeLift ''Bar
--   PlutusTx.makeIsDataIndexed ''Bar [('Bar, 0)]
--   
--   data PBar (a :: PType) (s :: S)
--     = PBar (Term s (PDataRecord '["_0" ':= a]))
--     deriving stock (GHC.Generic)
--     deriving anyclass (SOP.Generic, PIsDataRepr)
--     deriving (PlutusType, PIsData, PDataFields) via PIsDataReprInstances (PBar a)
--   
--   instance
--     forall a.
--     PLiftData a =&gt;
--     PUnsafeLiftDecl (PBar a)
--     where
--     type PLifted (PBar a) = Bar (PLifted a)
--   
--   deriving via
--     ( DerivePConstantViaData
--         (Bar a)
--         (PBar (PConstanted a))
--     )
--     instance
--       PConstantData a =&gt;
--       PConstantDecl (Bar a)
--   </pre>
type PConstantData h = (PConstant h, FromData h, ToData h, PIsData (PConstanted h))
type PLiftData p = (PLift p, FromData (PLifted p), ToData (PLifted p), PIsData p)
newtype TermCont :: forall (r :: PType). S -> Type -> Type
[TermCont] :: forall r s a. ((a -> Term s r) -> Term s r) -> TermCont @r s a
unTermCont :: TermCont @a s (Term s a) -> Term s a
tcont :: ((a -> Term s r) -> Term s r) -> TermCont @r s a
pupcast :: forall a b s. PSubtype a b => Term s b -> Term s a
ptryFrom :: forall b a s r. PTryFrom a b => Term s a -> ((Term s b, Reduce (PTryFromExcess a b s)) -> Term s r) -> Term s r

-- | <tt>PTryFrom a b</tt> represents a subtyping relationship between
--   <tt>a</tt> and <tt>b</tt>, and a way to go from <tt>a</tt> to
--   <tt>b</tt>. Laws: - <tt>(punsafeCoerce . fst) <a>$</a> tcont (ptryFrom
--   x) ≡ pure x</tt>
class PSubtype a b => PTryFrom (a :: PType) (b :: PType)

-- | <tt>PSubtype a b</tt> constitutes a subtyping relation between
--   <tt>a</tt> and <tt>b</tt>. This concretely means that `(x :: Term s b)
--   -&gt; punsafeCoerce x :: Term s a` is legal and sound.
--   
--   You can not make an instance for this yourself. You must use the
--   <a>PInner</a> type family of <tt>PlutusType</tt> to get this instance.
--   
--   Caveat: Only <tt>PInner a POpaque</tt> is considered unfortunately, as
--   otherwise getting GHC to figure out the relation with multiple
--   supertypes is quite hard.
--   
--   Subtyping is transitive.
type family PSubtype (a :: PType) (b :: PType) :: Constraint

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <a>id</a>
--   <a>to</a> . <a>from</a> ≡ <a>id</a>
--   </pre>
class Generic a

module Plutarch.Monadic

-- | Bind function used within do syntax.
--   
--   Enables elegant usage of <a>pmatch</a> and similar. <tt>P.do { y &lt;-
--   x ; z }</tt> is equivalent to <tt>x $ y -&gt; z</tt>.
--   
--   <pre>
--   import qualified Plutarch.Monadic as P
--   
--   f :: Term s (PTxInfo :--&gt; PBuiltinList (PAsData PTxInInfo))
--   f = plam $ x -&gt; P.do
--     PTxInfo txInfoFields &lt;- pmatch x
--     pfromData $ pdhead # txInfoFields
--   </pre>
(>>=) :: (x -> Term s a) -> x -> Term s a

-- | Forgetful bind function used within do syntax.
--   
--   Enables elegant usage of <a>ptrace</a> and similar. <tt>P.do { x ; y
--   }</tt> is equivalent to <tt>x y</tt>.
--   
--   <pre>
--   import qualified Plutarch.Monadic as P
--   
--   P.do
--     ptrace "yielding unit"
--     pconstant ()
--   </pre>
(>>) :: (x -> Term s a) -> x -> Term s a

-- | Implicitly invoked upon pattern match failure within do syntax.
--   
--   <pre>
--   import qualified Plutarch.Monadic as P
--   
--   P.do
--     -- calls <a>fail</a>, traces an error message, and invokes <a>perror</a>.
--     PTrue &lt;- pconstant False
--   </pre>
fail :: String -> Term s a

module Plutarch.Api.V1.Scripts
newtype PDatum (s :: S)
PDatum :: Term s PData -> PDatum (s :: S)
newtype PDatumHash (s :: S)
PDatumHash :: Term s PByteString -> PDatumHash (s :: S)
newtype PRedeemer (s :: S)
PRedeemer :: Term s PData -> PRedeemer (s :: S)
newtype PRedeemerHash (s :: S)
PRedeemerHash :: Term s PByteString -> PRedeemerHash (s :: S)
newtype PStakeValidatorHash (s :: S)
PStakeValidatorHash :: Term s PByteString -> PStakeValidatorHash (s :: S)
newtype PValidatorHash (s :: S)
PValidatorHash :: Term s PByteString -> PValidatorHash (s :: S)
instance Plutarch.Bool.PEq Plutarch.Api.V1.Scripts.PDatum
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Scripts.PDatum
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Scripts.PDatum
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Scripts.PDatum s)
instance Plutarch.Bool.PEq Plutarch.Api.V1.Scripts.PRedeemer
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Scripts.PRedeemer
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Scripts.PRedeemer
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Scripts.PRedeemer s)
instance Plutarch.Bool.POrd Plutarch.Api.V1.Scripts.PDatumHash
instance Plutarch.Bool.PEq Plutarch.Api.V1.Scripts.PDatumHash
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Scripts.PDatumHash
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Scripts.PDatumHash
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Scripts.PDatumHash s)
instance Plutarch.Bool.POrd Plutarch.Api.V1.Scripts.PStakeValidatorHash
instance Plutarch.Bool.PEq Plutarch.Api.V1.Scripts.PStakeValidatorHash
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Scripts.PStakeValidatorHash
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Scripts.PStakeValidatorHash
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Scripts.PStakeValidatorHash s)
instance Plutarch.Bool.POrd Plutarch.Api.V1.Scripts.PRedeemerHash
instance Plutarch.Bool.PEq Plutarch.Api.V1.Scripts.PRedeemerHash
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Scripts.PRedeemerHash
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Scripts.PRedeemerHash
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Scripts.PRedeemerHash s)
instance Plutarch.Bool.POrd Plutarch.Api.V1.Scripts.PValidatorHash
instance Plutarch.Bool.PEq Plutarch.Api.V1.Scripts.PValidatorHash
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Scripts.PValidatorHash
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Scripts.PValidatorHash
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Scripts.PValidatorHash s)
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Scripts.Datum
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Scripts.Redeemer
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Scripts.DatumHash
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Scripts.StakeValidatorHash
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Scripts.RedeemerHash
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Scripts.ValidatorHash
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Scripts.PValidatorHash
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Scripts.PValidatorHash
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Scripts.PRedeemerHash
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Scripts.PRedeemerHash
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Scripts.PStakeValidatorHash
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Scripts.PStakeValidatorHash
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Scripts.PDatumHash
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Scripts.PDatumHash
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Scripts.PRedeemer
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Scripts.PRedeemer
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Scripts.PDatum
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Scripts.PDatum

module Plutarch.Api.V1.Crypto
newtype PPubKeyHash (s :: S)
PPubKeyHash :: Term s PByteString -> PPubKeyHash (s :: S)
newtype PubKey
PubKey :: LedgerBytes -> PubKey
[getPubKey] :: PubKey -> LedgerBytes
pubKeyHash :: PubKey -> PubKeyHash
instance Plutarch.Bool.POrd Plutarch.Api.V1.Crypto.PPubKeyHash
instance Plutarch.Bool.PEq Plutarch.Api.V1.Crypto.PPubKeyHash
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Crypto.PPubKeyHash
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Crypto.PPubKeyHash
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Crypto.PPubKeyHash s)
instance GHC.Show.Show Plutarch.Api.V1.Crypto.PubKey
instance GHC.Classes.Ord Plutarch.Api.V1.Crypto.PubKey
instance GHC.Classes.Eq Plutarch.Api.V1.Crypto.PubKey
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Crypto.PubKeyHash
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Crypto.PPubKeyHash
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Crypto.PPubKeyHash

module Plutarch.Api.V1.Interval
newtype PInterval a (s :: S)
PInterval :: Term s (PDataRecord '["from" := PLowerBound a, "to" := PUpperBound a]) -> PInterval a (s :: S)
newtype PLowerBound a (s :: S)
PLowerBound :: Term s (PDataRecord '["_0" := PExtended a, "_1" := PClosure]) -> PLowerBound a (s :: S)
newtype PUpperBound a (s :: S)
PUpperBound :: Term s (PDataRecord '["_0" := PExtended a, "_1" := PClosure]) -> PUpperBound a (s :: S)
data PExtended a (s :: S)
PNegInf :: Term s (PDataRecord '[]) -> PExtended a (s :: S)
PFinite :: Term s (PDataRecord '["_0" := a]) -> PExtended a (s :: S)
PPosInf :: Term s (PDataRecord '[]) -> PExtended a (s :: S)
type PClosure = PBool
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Bool.POrd a, Plutarch.Builtin.PIsData a) => Plutarch.Bool.POrd (Plutarch.Api.V1.Interval.PExtended a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Bool.PEq (Plutarch.Api.V1.Interval.PExtended a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Builtin.PIsData (Plutarch.Api.V1.Interval.PExtended a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Api.V1.Interval.PExtended a)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Interval.PExtended a s)
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Bool.POrd a, Plutarch.Builtin.PIsData a) => Plutarch.Bool.POrd (Plutarch.Api.V1.Interval.PUpperBound a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Bool.PEq (Plutarch.Api.V1.Interval.PUpperBound a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.DataRepr.Internal.Field.PDataFields (Plutarch.Api.V1.Interval.PUpperBound a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Builtin.PIsData (Plutarch.Api.V1.Interval.PUpperBound a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Api.V1.Interval.PUpperBound a)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Interval.PUpperBound a s)
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Bool.POrd a, Plutarch.Builtin.PIsData a) => Plutarch.Bool.POrd (Plutarch.Api.V1.Interval.PLowerBound a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Bool.PEq (Plutarch.Api.V1.Interval.PLowerBound a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.DataRepr.Internal.Field.PDataFields (Plutarch.Api.V1.Interval.PLowerBound a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Builtin.PIsData (Plutarch.Api.V1.Interval.PLowerBound a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Api.V1.Interval.PLowerBound a)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Interval.PLowerBound a s)
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Bool.POrd a, Plutarch.Builtin.PIsData a) => Plutarch.Bool.POrd (Plutarch.Api.V1.Interval.PInterval a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Bool.PEq (Plutarch.Api.V1.Interval.PInterval a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.DataRepr.Internal.Field.PDataFields (Plutarch.Api.V1.Interval.PInterval a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Builtin.PIsData (Plutarch.Api.V1.Interval.PInterval a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Api.V1.Interval.PInterval a)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Interval.PInterval a s)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Api.V1.Interval.PInterval a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Api.V1.Interval.PLowerBound a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Api.V1.Interval.PUpperBound a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Api.V1.Interval.PExtended a)

module Plutarch.Api.V1.Time
newtype PPOSIXTime (s :: S)
PPOSIXTime :: Term s PInteger -> PPOSIXTime (s :: S)
type PPOSIXTimeRange = PInterval PPOSIXTime
instance Plutarch.Num.PNum Plutarch.Api.V1.Time.PPOSIXTime
instance Plutarch.Integer.PIntegral Plutarch.Api.V1.Time.PPOSIXTime
instance Plutarch.Bool.POrd Plutarch.Api.V1.Time.PPOSIXTime
instance Plutarch.Bool.PEq Plutarch.Api.V1.Time.PPOSIXTime
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Time.PPOSIXTime
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Time.PPOSIXTime
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Time.PPOSIXTime s)
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Time.POSIXTime
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Time.PPOSIXTime
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Time.PPOSIXTime

module Plutarch.Api.V1.Tuple
type PTuple a b = PDataSum '[ '["_0" := a, "_1" := b]]
ptuple :: Term s (PAsData a :--> (PAsData b :--> PTuple a b))
ptupleFromBuiltin :: Term s (PAsData (PBuiltinPair (PAsData a) (PAsData b))) -> Term s (PAsData (PTuple a b))
pbuiltinPairFromTuple :: Term s (PAsData (PTuple a b)) -> Term s (PAsData (PBuiltinPair (PAsData a) (PAsData b)))

module Plutarch.Api.V1.Maybe

-- | Data encoded Maybe type. Used in various ledger api types.
data PMaybeData a (s :: S)
PDJust :: Term s (PDataRecord '["_0" := a]) -> PMaybeData a (s :: S)
PDNothing :: Term s (PDataRecord '[]) -> PMaybeData a (s :: S)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Bool.PEq (Plutarch.Api.V1.Maybe.PMaybeData a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Builtin.PIsData (Plutarch.Api.V1.Maybe.PMaybeData a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Api.V1.Maybe.PMaybeData a)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Maybe.PMaybeData a s)
instance forall a. Plutarch.DataRepr.Internal.PConstantData a => Plutarch.Lift.PConstantDecl (GHC.Maybe.Maybe a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Api.V1.Maybe.PMaybeData a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.DataRepr.Internal.PLiftData a => Plutarch.Lift.PUnsafeLiftDecl (Plutarch.Api.V1.Maybe.PMaybeData a)
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Builtin.PIsData a, Plutarch.Bool.POrd a) => Plutarch.Bool.POrd (Plutarch.Api.V1.Maybe.PMaybeData a)

module Plutarch.Api.V1.Address
data PCredential (s :: S)
PPubKeyCredential :: Term s (PDataRecord '["_0" := PPubKeyHash]) -> PCredential (s :: S)
PScriptCredential :: Term s (PDataRecord '["_0" := PValidatorHash]) -> PCredential (s :: S)
data PStakingCredential (s :: S)
PStakingHash :: Term s (PDataRecord '["_0" := PCredential]) -> PStakingCredential (s :: S)
PStakingPtr :: Term s (PDataRecord '["_0" := PInteger, "_1" := PInteger, "_2" := PInteger]) -> PStakingCredential (s :: S)
newtype PAddress (s :: S)
PAddress :: Term s (PDataRecord '["credential" := PCredential, "stakingCredential" := PMaybeData PStakingCredential]) -> PAddress (s :: S)
instance Plutarch.Bool.POrd Plutarch.Api.V1.Address.PCredential
instance Plutarch.Bool.PEq Plutarch.Api.V1.Address.PCredential
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Address.PCredential
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Address.PCredential
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Address.PCredential s)
instance Plutarch.Bool.POrd Plutarch.Api.V1.Address.PStakingCredential
instance Plutarch.Bool.PEq Plutarch.Api.V1.Address.PStakingCredential
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Address.PStakingCredential
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Address.PStakingCredential
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Address.PStakingCredential s)
instance Plutarch.Bool.POrd Plutarch.Api.V1.Address.PAddress
instance Plutarch.Bool.PEq Plutarch.Api.V1.Address.PAddress
instance Plutarch.DataRepr.Internal.Field.PDataFields Plutarch.Api.V1.Address.PAddress
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Address.PAddress
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Address.PAddress
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Address.PAddress s)
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Credential.Credential
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Credential.StakingCredential
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Address.Address
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Address.PAddress
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Address.PAddress
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Address.PStakingCredential
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Address.PStakingCredential
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Address.PCredential
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Address.PCredential

module Plutarch.Api.V1.DCert
data PDCert (s :: S)
PDCertDelegRegKey :: Term s (PDataRecord '["_0" := PStakingCredential]) -> PDCert (s :: S)
PDCertDelegDeRegKey :: Term s (PDataRecord '["_0" := PStakingCredential]) -> PDCert (s :: S)
PDCertDelegDelegate :: Term s (PDataRecord '["_0" := PStakingCredential, "_1" := PPubKeyHash]) -> PDCert (s :: S)
PDCertPoolRegister :: Term s (PDataRecord '["_0" := PPubKeyHash, "_1" := PPubKeyHash]) -> PDCert (s :: S)
PDCertPoolRetire :: Term s (PDataRecord '["_0" := PPubKeyHash, "_1" := PInteger]) -> PDCert (s :: S)
PDCertGenesis :: Term s (PDataRecord '[]) -> PDCert (s :: S)
PDCertMir :: Term s (PDataRecord '[]) -> PDCert (s :: S)
instance Plutarch.Bool.POrd Plutarch.Api.V1.DCert.PDCert
instance Plutarch.Bool.PEq Plutarch.Api.V1.DCert.PDCert
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.DCert.PDCert
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.DCert.PDCert
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.DCert.PDCert s)
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.DCert.DCert
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.DCert.PDCert
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.DCert.PDCert

module Plutarch.Api.V1.AssocMap
newtype PMap (keysort :: KeyGuarantees) (k :: PType) (v :: PType) (s :: S)
PMap :: Term s (PBuiltinMap k v) -> PMap (keysort :: KeyGuarantees) (k :: PType) (v :: PType) (s :: S)
data KeyGuarantees
Sorted :: KeyGuarantees
Unsorted :: KeyGuarantees

-- | Construct an empty <a>PMap</a>.
pempty :: Term s (PMap 'Sorted k v)

-- | Construct a singleton <a>PMap</a> with the given key and value.
psingleton :: (PIsData k, PIsData v) => Term s (k :--> (v :--> PMap 'Sorted k v))

-- | Construct a singleton <a>PMap</a> with the given data-encoded key and
--   value.
psingletonData :: Term s (PAsData k :--> (PAsData v :--> PMap 'Sorted k v))

-- | Insert a new key/value pair into the map, overiding the previous if
--   any.
pinsert :: (POrd k, PIsData k, PIsData v) => Term s (k :--> (v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v)))

-- | Insert a new data-encoded key/value pair into the map, overiding the
--   previous if any.
pinsertData :: (POrd k, PIsData k) => Term s (PAsData k :--> (PAsData v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v)))

-- | Delete a key from the map.
pdelete :: (POrd k, PIsData k) => Term s (k :--> (PMap 'Sorted k v :--> PMap 'Sorted k v))

-- | Construct a <a>PMap</a> from a list of key-value pairs, sorted by
--   ascending key data.
pfromAscList :: (POrd k, PIsData k, PIsData v) => Term s (PBuiltinMap k v :--> PMap 'Sorted k v)

-- | Assert the map is properly sorted.
passertSorted :: (POrd k, PIsData k, PIsData v) => Term s (PMap _ k v :--> PMap 'Sorted k v)

-- | Forget the knowledge that keys were sorted.
pforgetSorted :: Term s (PMap 'Sorted k v) -> Term s (PMap g k v)

-- | Look up the given key in a <a>PMap</a>.
plookup :: (PIsData k, PIsData v) => Term s (k :--> (PMap _ k v :--> PMaybe v))

-- | Look up the given key data in a <a>PMap</a>.
plookupData :: (PIsData k, PIsData v) => Term s (PAsData k :--> (PMap _ k v :--> PMaybe (PAsData v)))

-- | Look up the given key in a <a>PMap</a>, returning the default value if
--   the key is absent.
pfindWithDefault :: (PIsData k, PIsData v) => Term s (v :--> (k :--> (PMap _ k v :--> v)))

-- | Look up the given key in a <a>PMap</a>; return the default if the key
--   is absent or apply the argument function to the value data if present.
pfoldAt :: (PIsData k, PIsData v) => Term s (k :--> (r :--> ((PAsData v :--> r) :--> (PMap _ k v :--> r))))

-- | Tests whether the map is empty.
pnull :: Term s (PMap _ k v :--> PBool)

-- | Tests if all values in the map satisfy the given predicate.
pall :: PIsData v => Term s ((v :--> PBool) :--> (PMap _ k v :--> PBool))

-- | Tests if anu value in the map satisfies the given predicate.
pany :: PIsData v => Term s ((v :--> PBool) :--> (PMap _ k v :--> PBool))

-- | Filters the map so it contains only the values that satisfy the given
--   predicate.
pfilter :: PIsData v => Term s ((v :--> PBool) :--> (PMap g k v :--> PMap g k v))

-- | Applies a function to every value in the map, much like <a>map</a>.
pmap :: (PIsData a, PIsData b) => Term s ((a :--> b) :--> (PMap g k a :--> PMap g k b))
pmapData :: Term s ((PAsData a :--> PAsData b) :--> (PMap g k a :--> PMap g k b))

-- | Maps and filters the map, much like <a>mapMaybe</a>.
pmapMaybe :: (PIsData a, PIsData b) => Term s ((a :--> PMaybe b) :--> (PMap g k a :--> PMap g k b))
pmapMaybeData :: Term s ((PAsData a :--> PMaybe (PAsData b)) :--> (PMap g k a :--> PMap g k b))

-- | Difference of two maps. Return elements of the first map not existing
--   in the second map.
pdifference :: (PIsData k, PIsData a, PIsData b) => Term s (PMap g k a :--> (PMap _ k b :--> PMap g k a))

-- | Combine two <a>PMap</a>s applying the given function to any two values
--   that share the same key.
punionWith :: (POrd k, PIsData k, PIsData v) => Term s ((v :--> (v :--> v)) :--> (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v)))

-- | Combine two <a>PMap</a>s applying the given function to any two
--   data-encoded values that share the same key.
punionWithData :: (POrd k, PIsData k) => Term s ((PAsData v :--> (PAsData v :--> PAsData v)) :--> (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v)))
instance forall (keysort :: Plutarch.Api.V1.AssocMap.KeyGuarantees) (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType). (Plutarch.Builtin.PIsData k, Plutarch.Builtin.PIsData v, Plutarch.Show.PShow k, Plutarch.Show.PShow v) => Plutarch.Show.PShow (Plutarch.Api.V1.AssocMap.PMap keysort k v)
instance forall (keysort :: Plutarch.Api.V1.AssocMap.KeyGuarantees) (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType). Plutarch.Bool.PEq (Plutarch.Api.V1.AssocMap.PMap keysort k v)
instance forall (keysort :: Plutarch.Api.V1.AssocMap.KeyGuarantees) (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType). Plutarch.Builtin.PIsData (Plutarch.Api.V1.AssocMap.PMap keysort k v)
instance forall (keysort :: Plutarch.Api.V1.AssocMap.KeyGuarantees) (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Api.V1.AssocMap.PMap keysort k v)
instance forall (keysort :: Plutarch.Api.V1.AssocMap.KeyGuarantees) (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.AssocMap.PMap keysort k v s)
instance forall (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Api.V1.AssocMap.MapUnionCarrier k v)
instance forall (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.AssocMap.MapUnionCarrier k v s)
instance forall (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Api.V1.AssocMap.MapUnionCarrier k v)
instance forall (keysort :: Plutarch.Api.V1.AssocMap.KeyGuarantees) (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Api.V1.AssocMap.PMap keysort k v)
instance forall (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType). (Plutarch.DataRepr.Internal.PLiftData k, Plutarch.DataRepr.Internal.PLiftData v, GHC.Classes.Ord (Plutarch.Lift.PLifted k)) => Plutarch.Lift.PUnsafeLiftDecl (Plutarch.Api.V1.AssocMap.PMap 'Plutarch.Api.V1.AssocMap.Unsorted k v)
instance forall k v. (Plutarch.DataRepr.Internal.PConstantData k, Plutarch.DataRepr.Internal.PConstantData v, GHC.Classes.Ord k) => Plutarch.Lift.PConstantDecl (PlutusTx.AssocMap.Map k v)
instance forall (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). (Plutarch.Bool.POrd k, Plutarch.Builtin.PIsData k, Plutarch.Builtin.PIsData v, GHC.Base.Semigroup (Plutarch.Internal.Term s v)) => GHC.Base.Semigroup (Plutarch.Internal.Term s (Plutarch.Api.V1.AssocMap.PMap 'Plutarch.Api.V1.AssocMap.Sorted k v))
instance forall (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). (Plutarch.Bool.POrd k, Plutarch.Builtin.PIsData k, Plutarch.Builtin.PIsData v, GHC.Base.Semigroup (Plutarch.Internal.Term s v)) => GHC.Base.Monoid (Plutarch.Internal.Term s (Plutarch.Api.V1.AssocMap.PMap 'Plutarch.Api.V1.AssocMap.Sorted k v))
instance forall (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). (Plutarch.Bool.POrd k, Plutarch.Builtin.PIsData k, Plutarch.Builtin.PIsData v, PlutusTx.Semigroup.Semigroup (Plutarch.Internal.Term s v)) => PlutusTx.Semigroup.Semigroup (Plutarch.Internal.Term s (Plutarch.Api.V1.AssocMap.PMap 'Plutarch.Api.V1.AssocMap.Sorted k v))
instance forall (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). (Plutarch.Bool.POrd k, Plutarch.Builtin.PIsData k, Plutarch.Builtin.PIsData v, PlutusTx.Semigroup.Semigroup (Plutarch.Internal.Term s v)) => PlutusTx.Monoid.Monoid (Plutarch.Internal.Term s (Plutarch.Api.V1.AssocMap.PMap 'Plutarch.Api.V1.AssocMap.Sorted k v))
instance forall (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). (Plutarch.Bool.POrd k, Plutarch.Builtin.PIsData k, Plutarch.Builtin.PIsData v, PlutusTx.Monoid.Group (Plutarch.Internal.Term s v)) => PlutusTx.Monoid.Group (Plutarch.Internal.Term s (Plutarch.Api.V1.AssocMap.PMap 'Plutarch.Api.V1.AssocMap.Sorted k v))


-- | Value-related functionality. In order to keep the interface efficient
--   and safe at the same time, there is a type-level distinction between
--   <a>PValue</a>s that are guaranteed to be properly normalized and those
--   that provide no such guarantee.
--   
--   Also for efficiency reasons, the Ada-specific functions assume that
--   there can be only one token name for the Ada currency symbol, and they
--   don't check whether it matches <a>adaToken</a>.
module Plutarch.Api.V1.Value
newtype PValue (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S)
PValue :: Term s (PMap keys PCurrencySymbol (PMap keys PTokenName PInteger)) -> PValue (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S)
newtype PCurrencySymbol (s :: S)
PCurrencySymbol :: Term s PByteString -> PCurrencySymbol (s :: S)
newtype PTokenName (s :: S)
PTokenName :: Term s PByteString -> PTokenName (s :: S)
data KeyGuarantees
Sorted :: KeyGuarantees
Unsorted :: KeyGuarantees
data AmountGuarantees
NoGuarantees :: AmountGuarantees
NonZero :: AmountGuarantees
Positive :: AmountGuarantees

-- | Assert the value is properly sorted and normalized.
passertSorted :: Term s (PValue _ _ :--> PValue 'Sorted 'NonZero)

-- | Assert all amounts in the value are positive.
passertPositive :: Term s (PValue 'Sorted 'NonZero :--> PValue 'Sorted 'Positive)

-- | Forget the knowledge of value's positivity.
pforgetPositive :: Term s (PValue 'Sorted 'Positive) -> Term s (PValue k a)

-- | Forget the knowledge of all value's guarantees.
pforgetSorted :: Term s (PValue 'Sorted a) -> Term s (PValue k b)

-- | Normalize the argument to contain no zero quantity nor empty token
--   map.
pnormalize :: Term s (PValue 'Sorted _ :--> PValue 'Sorted 'NonZero)

-- | Construct a singleton <a>PValue</a> containing only the given quantity
--   of the given currency.
psingleton :: Term s (PCurrencySymbol :--> (PTokenName :--> (PInteger :--> PValue 'Sorted 'NonZero)))

-- | Construct a singleton <a>PValue</a> containing only the given quantity
--   of the given currency, taking data-encoded parameters.
psingletonData :: Term s (PAsData PCurrencySymbol :--> (PAsData PTokenName :--> (PAsData PInteger :--> PValue 'Sorted 'NonZero)))

-- | Construct a constant singleton <a>PValue</a> containing only the given
--   quantity of the given currency.
pconstantSingleton :: ClosedTerm PCurrencySymbol -> ClosedTerm PTokenName -> ClosedTerm PInteger -> ClosedTerm (PValue 'Sorted 'NonZero)

-- | Construct a constant singleton <a>PValue</a> containing only the given
--   positive quantity of the given currency.
pconstantPositiveSingleton :: ClosedTerm PCurrencySymbol -> ClosedTerm PTokenName -> ClosedTerm PInteger -> ClosedTerm (PValue 'Sorted 'Positive)

-- | Combine two <a>PValue</a>s applying the given function to any pair of
--   quantities with the same asset class. Note that the result is _not_
--   <tt>normalize</tt>d and may contain zero quantities.
punionWith :: Term s ((PInteger :--> (PInteger :--> PInteger)) :--> (PValue 'Sorted _ :--> (PValue 'Sorted _ :--> PValue 'Sorted 'NoGuarantees)))

-- | Combine two <a>PValue</a>s applying the given function to any pair of
--   data-encoded quantities with the same asset class. Note that the
--   result is _not_ <tt>normalize</tt>d and may contain zero quantities.
punionWithData :: Term s ((PAsData PInteger :--> (PAsData PInteger :--> PAsData PInteger)) :--> (PValue 'Sorted _ :--> (PValue 'Sorted _ :--> PValue 'Sorted 'NoGuarantees)))

-- | Get the quantity of the given currency in the <a>PValue</a>.
pvalueOf :: Term s (PValue _ _ :--> (PCurrencySymbol :--> (PTokenName :--> PInteger)))

-- | The amount of Lovelace in value
plovelaceValueOf :: Term s (PValue 'Sorted v :--> PInteger)

-- | The <a>PCurrencySymbol</a> of the Ada currency.
padaSymbol :: Term s PCurrencySymbol

-- | Data-encoded <a>PCurrencySymbol</a> of the Ada currency.
padaSymbolData :: Term s (PAsData PCurrencySymbol)

-- | The <a>PTokenName</a> of the Ada currency.
padaToken :: Term s PTokenName

-- | Data-encoded <a>PTokenName</a> of the Ada currency.
padaTokenData :: Term s (PAsData PTokenName)

-- | Test if the value contains nothing but Ada
pisAdaOnlyValue :: Term s (PValue 'Sorted 'Positive :--> PBool)

-- | Value without any non-Ada
padaOnlyValue :: Term s (PValue 'Sorted v :--> PValue 'Sorted v)

-- | Value without any Ada
pnoAdaValue :: Term s (PValue 'Sorted v :--> PValue 'Sorted v)
instance Plutarch.Bool.POrd Plutarch.Api.V1.Value.PTokenName
instance Plutarch.Bool.PEq Plutarch.Api.V1.Value.PTokenName
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Value.PTokenName
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Value.PTokenName
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Value.PTokenName s)
instance Plutarch.Bool.POrd Plutarch.Api.V1.Value.PCurrencySymbol
instance Plutarch.Bool.PEq Plutarch.Api.V1.Value.PCurrencySymbol
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Value.PCurrencySymbol
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Value.PCurrencySymbol
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Value.PCurrencySymbol s)
instance forall (keys :: Plutarch.Api.V1.AssocMap.KeyGuarantees) (amounts :: Plutarch.Api.V1.Value.AmountGuarantees). Plutarch.Builtin.PIsData (Plutarch.Api.V1.Value.PValue keys amounts)
instance forall (keys :: Plutarch.Api.V1.AssocMap.KeyGuarantees) (amounts :: Plutarch.Api.V1.Value.AmountGuarantees). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Api.V1.Value.PValue keys amounts)
instance forall (keys :: Plutarch.Api.V1.AssocMap.KeyGuarantees) (amounts :: Plutarch.Api.V1.Value.AmountGuarantees) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Value.PValue keys amounts s)
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Value.TokenName
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Value.CurrencySymbol
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Value.Value
instance forall (keys :: Plutarch.Api.V1.AssocMap.KeyGuarantees) (amounts :: Plutarch.Api.V1.Value.AmountGuarantees). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Api.V1.Value.PValue keys amounts)
instance Plutarch.Lift.PUnsafeLiftDecl (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Unsorted 'Plutarch.Api.V1.Value.NonZero)
instance Plutarch.Bool.PEq (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.Positive)
instance Plutarch.Bool.PEq (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.NonZero)
instance Plutarch.Bool.PEq (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.NoGuarantees)
instance forall (s :: Plutarch.Internal.S). GHC.Base.Semigroup (Plutarch.Internal.Term s (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.Positive))
instance forall (s :: Plutarch.Internal.S). PlutusTx.Semigroup.Semigroup (Plutarch.Internal.Term s (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.Positive))
instance forall (s :: Plutarch.Internal.S). GHC.Base.Semigroup (Plutarch.Internal.Term s (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.NonZero))
instance forall (s :: Plutarch.Internal.S). PlutusTx.Semigroup.Semigroup (Plutarch.Internal.Term s (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.NonZero))
instance forall (s :: Plutarch.Internal.S). GHC.Base.Semigroup (Plutarch.Internal.Term s (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.NoGuarantees))
instance forall (s :: Plutarch.Internal.S). PlutusTx.Semigroup.Semigroup (Plutarch.Internal.Term s (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.NoGuarantees))
instance forall (s :: Plutarch.Internal.S) (normalization :: Plutarch.Api.V1.Value.AmountGuarantees). GHC.Base.Semigroup (Plutarch.Internal.Term s (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted normalization)) => GHC.Base.Monoid (Plutarch.Internal.Term s (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted normalization))
instance forall (s :: Plutarch.Internal.S) (normalization :: Plutarch.Api.V1.Value.AmountGuarantees). PlutusTx.Semigroup.Semigroup (Plutarch.Internal.Term s (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted normalization)) => PlutusTx.Monoid.Monoid (Plutarch.Internal.Term s (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted normalization))
instance forall (s :: Plutarch.Internal.S). PlutusTx.Semigroup.Semigroup (Plutarch.Internal.Term s (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.NoGuarantees)) => PlutusTx.Monoid.Group (Plutarch.Internal.Term s (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.NoGuarantees))
instance forall (s :: Plutarch.Internal.S). PlutusTx.Semigroup.Semigroup (Plutarch.Internal.Term s (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.NonZero)) => PlutusTx.Monoid.Group (Plutarch.Internal.Term s (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.NonZero))
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Value.PCurrencySymbol
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Value.PCurrencySymbol
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Value.PTokenName
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Value.PTokenName

module Plutarch.Api.V1.Tx

-- | Reference to a transaction output with a index referencing which of
--   the outputs is being referred to.
newtype PTxOutRef (s :: S)
PTxOutRef :: Term s (PDataRecord '["id" := PTxId, "idx" := PInteger]) -> PTxOutRef (s :: S)

-- | A transaction output. This consists of a target address, value and
--   maybe a datum hash
newtype PTxOut (s :: S)
PTxOut :: Term s (PDataRecord '["address" := PAddress, "value" := PValue 'Sorted 'Positive, "datumHash" := PMaybeData PDatumHash]) -> PTxOut (s :: S)
newtype PTxId (s :: S)
PTxId :: Term s (PDataRecord '["_0" := PByteString]) -> PTxId (s :: S)

-- | A input of the pending transaction.
newtype PTxInInfo (s :: S)
PTxInInfo :: Term s (PDataRecord '["outRef" := PTxOutRef, "resolved" := PTxOut]) -> PTxInInfo (s :: S)
instance Plutarch.Bool.POrd Plutarch.Api.V1.Tx.PTxId
instance Plutarch.Bool.PEq Plutarch.Api.V1.Tx.PTxId
instance Plutarch.DataRepr.Internal.Field.PDataFields Plutarch.Api.V1.Tx.PTxId
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Tx.PTxId
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Tx.PTxId
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Tx.PTxId s)
instance Plutarch.Bool.POrd Plutarch.Api.V1.Tx.PTxOutRef
instance Plutarch.Bool.PEq Plutarch.Api.V1.Tx.PTxOutRef
instance Plutarch.DataRepr.Internal.Field.PDataFields Plutarch.Api.V1.Tx.PTxOutRef
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Tx.PTxOutRef
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Tx.PTxOutRef
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Tx.PTxOutRef s)
instance Plutarch.Bool.PEq Plutarch.Api.V1.Tx.PTxOut
instance Plutarch.DataRepr.Internal.Field.PDataFields Plutarch.Api.V1.Tx.PTxOut
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Tx.PTxOut
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Tx.PTxOut
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Tx.PTxOut s)
instance Plutarch.Bool.PEq Plutarch.Api.V1.Tx.PTxInInfo
instance Plutarch.DataRepr.Internal.Field.PDataFields Plutarch.Api.V1.Tx.PTxInInfo
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Tx.PTxInInfo
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Tx.PTxInInfo
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Tx.PTxInInfo s)
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Tx.TxId
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Tx.TxOutRef
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Contexts.TxInInfo
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Tx.TxOut
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Tx.PTxInInfo
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Tx.PTxInInfo
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Tx.PTxOut
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Tx.PTxOut
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Tx.PTxOutRef
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Tx.PTxOutRef
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Tx.PTxId
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Tx.PTxId

module Plutarch.Api.V1.Contexts
type PTuple a b = PDataSum '[ '["_0" := a, "_1" := b]]

-- | Script context consists of the script purpose and the pending
--   transaction info.
newtype PScriptContext (s :: S)
PScriptContext :: Term s (PDataRecord '["txInfo" := PTxInfo, "purpose" := PScriptPurpose]) -> PScriptContext (s :: S)

-- | A pending transaction. This is the view as seen by the validator
--   script.
newtype PTxInfo (s :: S)
PTxInfo :: Term s (PDataRecord '["inputs" := PBuiltinList (PAsData PTxInInfo), "outputs" := PBuiltinList (PAsData PTxOut), "fee" := PValue 'Sorted 'Positive, "mint" := PValue 'Sorted 'NoGuarantees, "dcert" := PBuiltinList (PAsData PDCert), "wdrl" := PBuiltinList (PAsData (PTuple PStakingCredential PInteger)), "validRange" := PPOSIXTimeRange, "signatories" := PBuiltinList (PAsData PPubKeyHash), "datums" := PBuiltinList (PAsData (PTuple PDatumHash PDatum)), "id" := PTxId]) -> PTxInfo (s :: S)

-- | The purpose of the script that is currently running
data PScriptPurpose (s :: S)
PMinting :: Term s (PDataRecord '["_0" := PCurrencySymbol]) -> PScriptPurpose (s :: S)
PSpending :: Term s (PDataRecord '["_0" := PTxOutRef]) -> PScriptPurpose (s :: S)
PRewarding :: Term s (PDataRecord '["_0" := PStakingCredential]) -> PScriptPurpose (s :: S)
PCertifying :: Term s (PDataRecord '["_0" := PDCert]) -> PScriptPurpose (s :: S)
instance Plutarch.Bool.PEq Plutarch.Api.V1.Contexts.PTxInfo
instance Plutarch.DataRepr.Internal.Field.PDataFields Plutarch.Api.V1.Contexts.PTxInfo
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Contexts.PTxInfo
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Contexts.PTxInfo
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Contexts.PTxInfo s)
instance Plutarch.Bool.PEq Plutarch.Api.V1.Contexts.PScriptPurpose
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Contexts.PScriptPurpose
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Contexts.PScriptPurpose
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Contexts.PScriptPurpose s)
instance Plutarch.Bool.PEq Plutarch.Api.V1.Contexts.PScriptContext
instance Plutarch.DataRepr.Internal.Field.PDataFields Plutarch.Api.V1.Contexts.PScriptContext
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Contexts.PScriptContext
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Contexts.PScriptContext
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Contexts.PScriptContext s)
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Contexts.TxInfo
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Contexts.ScriptContext
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Contexts.ScriptPurpose
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Contexts.PScriptContext
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Contexts.PScriptContext
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Contexts.PScriptPurpose
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Contexts.PScriptPurpose
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Contexts.PTxInfo
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Contexts.PTxInfo

module Plutarch.Api.V1

-- | Script context consists of the script purpose and the pending
--   transaction info.
newtype PScriptContext (s :: S)
PScriptContext :: Term s (PDataRecord '["txInfo" := PTxInfo, "purpose" := PScriptPurpose]) -> PScriptContext (s :: S)

-- | A pending transaction. This is the view as seen by the validator
--   script.
newtype PTxInfo (s :: S)
PTxInfo :: Term s (PDataRecord '["inputs" := PBuiltinList (PAsData PTxInInfo), "outputs" := PBuiltinList (PAsData PTxOut), "fee" := PValue 'Sorted 'Positive, "mint" := PValue 'Sorted 'NoGuarantees, "dcert" := PBuiltinList (PAsData PDCert), "wdrl" := PBuiltinList (PAsData (PTuple PStakingCredential PInteger)), "validRange" := PPOSIXTimeRange, "signatories" := PBuiltinList (PAsData PPubKeyHash), "datums" := PBuiltinList (PAsData (PTuple PDatumHash PDatum)), "id" := PTxId]) -> PTxInfo (s :: S)

-- | The purpose of the script that is currently running
data PScriptPurpose (s :: S)
PMinting :: Term s (PDataRecord '["_0" := PCurrencySymbol]) -> PScriptPurpose (s :: S)
PSpending :: Term s (PDataRecord '["_0" := PTxOutRef]) -> PScriptPurpose (s :: S)
PRewarding :: Term s (PDataRecord '["_0" := PStakingCredential]) -> PScriptPurpose (s :: S)
PCertifying :: Term s (PDataRecord '["_0" := PDCert]) -> PScriptPurpose (s :: S)
newtype PDatum (s :: S)
PDatum :: Term s PData -> PDatum (s :: S)
newtype PDatumHash (s :: S)
PDatumHash :: Term s PByteString -> PDatumHash (s :: S)
newtype PRedeemer (s :: S)
PRedeemer :: Term s PData -> PRedeemer (s :: S)
newtype PRedeemerHash (s :: S)
PRedeemerHash :: Term s PByteString -> PRedeemerHash (s :: S)
newtype PStakeValidatorHash (s :: S)
PStakeValidatorHash :: Term s PByteString -> PStakeValidatorHash (s :: S)
newtype PValidatorHash (s :: S)
PValidatorHash :: Term s PByteString -> PValidatorHash (s :: S)

-- | Hash a Validator, with the correct prefix for Plutus V1
validatorHash :: Validator -> ValidatorHash

-- | Hash a MintingPolicy, with the correct prefix for Plutus V1
mintingPolicySymbol :: MintingPolicy -> CurrencySymbol

-- | Hash a StakeValidator, with the correct prefix for Plutus V1
stakeValidatorHash :: StakeValidator -> StakeValidatorHash

-- | Hash a Script, with the correct prefix for Plutus V1
scriptHash :: Script -> ScriptHash

-- | Hash a Datum.
datumHash :: Datum -> DatumHash

-- | Hash a Redeemer.
redeemerHash :: Redeemer -> RedeemerHash

-- | Hash the data encoded representation of given argument.
dataHash :: ToData a => a -> BuiltinByteString

-- | Compile a Validator
mkValidator :: HasCallStack => Config -> ClosedTerm PValidator -> Validator

-- | Compile a StakeValidator
mkStakeValidator :: HasCallStack => Config -> ClosedTerm PStakeValidator -> StakeValidator

-- | Compile a MintingPolicy
mkMintingPolicy :: HasCallStack => Config -> ClosedTerm PMintingPolicy -> MintingPolicy

-- | a Validator Term
type PValidator = PData :--> PData :--> PScriptContext :--> POpaque

-- | a MintingPolicy Term
type PMintingPolicy = PData :--> PScriptContext :--> POpaque

-- | a StakeValidator Term
type PStakeValidator = PData :--> PScriptContext :--> POpaque
newtype PValue (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S)
PValue :: Term s (PMap keys PCurrencySymbol (PMap keys PTokenName PInteger)) -> PValue (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S)
newtype PCurrencySymbol (s :: S)
PCurrencySymbol :: Term s PByteString -> PCurrencySymbol (s :: S)
newtype PTokenName (s :: S)
PTokenName :: Term s PByteString -> PTokenName (s :: S)
data KeyGuarantees
Sorted :: KeyGuarantees
Unsorted :: KeyGuarantees
data AmountGuarantees
NoGuarantees :: AmountGuarantees
NonZero :: AmountGuarantees
Positive :: AmountGuarantees
newtype PPubKeyHash (s :: S)
PPubKeyHash :: Term s PByteString -> PPubKeyHash (s :: S)
pubKeyHash :: PubKey -> PubKeyHash
data PDCert (s :: S)
PDCertDelegRegKey :: Term s (PDataRecord '["_0" := PStakingCredential]) -> PDCert (s :: S)
PDCertDelegDeRegKey :: Term s (PDataRecord '["_0" := PStakingCredential]) -> PDCert (s :: S)
PDCertDelegDelegate :: Term s (PDataRecord '["_0" := PStakingCredential, "_1" := PPubKeyHash]) -> PDCert (s :: S)
PDCertPoolRegister :: Term s (PDataRecord '["_0" := PPubKeyHash, "_1" := PPubKeyHash]) -> PDCert (s :: S)
PDCertPoolRetire :: Term s (PDataRecord '["_0" := PPubKeyHash, "_1" := PInteger]) -> PDCert (s :: S)
PDCertGenesis :: Term s (PDataRecord '[]) -> PDCert (s :: S)
PDCertMir :: Term s (PDataRecord '[]) -> PDCert (s :: S)
data PPOSIXTime (s :: S)
type PPOSIXTimeRange = PInterval PPOSIXTime
newtype PInterval a (s :: S)
PInterval :: Term s (PDataRecord '["from" := PLowerBound a, "to" := PUpperBound a]) -> PInterval a (s :: S)
newtype PLowerBound a (s :: S)
PLowerBound :: Term s (PDataRecord '["_0" := PExtended a, "_1" := PClosure]) -> PLowerBound a (s :: S)
newtype PUpperBound a (s :: S)
PUpperBound :: Term s (PDataRecord '["_0" := PExtended a, "_1" := PClosure]) -> PUpperBound a (s :: S)
data PExtended a (s :: S)
PNegInf :: Term s (PDataRecord '[]) -> PExtended a (s :: S)
PFinite :: Term s (PDataRecord '["_0" := a]) -> PExtended a (s :: S)
PPosInf :: Term s (PDataRecord '[]) -> PExtended a (s :: S)
type PClosure = PBool
data PCredential (s :: S)
PPubKeyCredential :: Term s (PDataRecord '["_0" := PPubKeyHash]) -> PCredential (s :: S)
PScriptCredential :: Term s (PDataRecord '["_0" := PValidatorHash]) -> PCredential (s :: S)
data PStakingCredential (s :: S)
PStakingHash :: Term s (PDataRecord '["_0" := PCredential]) -> PStakingCredential (s :: S)
PStakingPtr :: Term s (PDataRecord '["_0" := PInteger, "_1" := PInteger, "_2" := PInteger]) -> PStakingCredential (s :: S)
newtype PAddress (s :: S)
PAddress :: Term s (PDataRecord '["credential" := PCredential, "stakingCredential" := PMaybeData PStakingCredential]) -> PAddress (s :: S)

-- | Reference to a transaction output with a index referencing which of
--   the outputs is being referred to.
newtype PTxOutRef (s :: S)
PTxOutRef :: Term s (PDataRecord '["id" := PTxId, "idx" := PInteger]) -> PTxOutRef (s :: S)

-- | A transaction output. This consists of a target address, value and
--   maybe a datum hash
newtype PTxOut (s :: S)
PTxOut :: Term s (PDataRecord '["address" := PAddress, "value" := PValue 'Sorted 'Positive, "datumHash" := PMaybeData PDatumHash]) -> PTxOut (s :: S)
newtype PTxId (s :: S)
PTxId :: Term s (PDataRecord '["_0" := PByteString]) -> PTxId (s :: S)

-- | A input of the pending transaction.
newtype PTxInInfo (s :: S)
PTxInInfo :: Term s (PDataRecord '["outRef" := PTxOutRef, "resolved" := PTxOut]) -> PTxInInfo (s :: S)
newtype PMap (keysort :: KeyGuarantees) (k :: PType) (v :: PType) (s :: S)
PMap :: Term s (PBuiltinMap k v) -> PMap (keysort :: KeyGuarantees) (k :: PType) (v :: PType) (s :: S)

-- | Data encoded Maybe type. Used in various ledger api types.
data PMaybeData a (s :: S)
PDJust :: Term s (PDataRecord '["_0" := a]) -> PMaybeData a (s :: S)
PDNothing :: Term s (PDataRecord '[]) -> PMaybeData a (s :: S)
type PTuple a b = PDataSum '[ '["_0" := a, "_1" := b]]
ptuple :: Term s (PAsData a :--> (PAsData b :--> PTuple a b))
